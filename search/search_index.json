{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ACMESky - Documentazione progetto Il seguente report descrive i processi che hanno portato alla realizzazione del progetto didattico del corso Ingegneria del Software Orientata ai Servizi della LM Informatica dell'Universit\u00e0 di Bologna, svolto da Marco Ferrati e Tommaso Azzalin nell'A.A. 2020/2021. Descrizione del progetto Realizzare una Service Oriented Architecture ( SOA ) che rappresenti la realt\u00e0 di una compagnia chiamata ACMESky . ACMESky fornisce ai propri utenti la possibilit\u00e0 di venire notificati e successivamente acquistare offerte di voli A/R in determinate date e al di sotto di una certa soglia di prezzo, da loro scelte in precedenza. ACMESky si relaziona con diversi servizi esterni all'organizzazione: le compagnie aeree (o Flight Company ) per il controllo della presenza di offerte e l'acquisto dei voli; le compagnie di noleggio con autista , da noi rinominate in compagnie di trasporto (o Travel Company ), per la prenotazione del trasporto gratuito degli utenti da casa all'aeroporto e viceversa; il servizio per il calcolo delle distanze geografiche (o Geographical Distances ); il sistema bancario, da noi rinominato in provider di pagamenti (o Payment Provider ), che si occupa di gestire i pagamenti per l'acquisto dei voli da parte degli utenti; il servizio ProntoGram , con il quale contattare gli utenti per comunicar loro i codici delle offerte. Assunzioni e semplificazioni Essendo un progetto a scopo didattico sono state adottate alcune assunzioni e semplificazioni sul funzionamento dei vari servizi, che vengono elencati di seguito: gli aspetti relativi alla sicurezza delle comunicazioni e dei dati sono stati ignorati mentre, ad esempio, sarebbe stato corretto utilizzare il protocollo HTTPS per le comunicazioni, gestire l'autenticazione degli utenti su ProntoGram , separare i dati in diverse tabelle e cifrare quelli personali; i voli offerti dalle compagnie aeree sono tutti diretti e quando vengono assegnati ad un offerta ACMESky chiede di riservare un posto alle compagnie aeree in modo da evitare, al momento dell'acquisto, un errore dovuto alla mancanza di disponibilit\u00e0 di posti a sedere; un'offerta di viaggio \u00e8 composta di solo due voli di un'unica compagnia aerea , quelli con prezzo inferiore in tutto il range di date indicato dall'utente, questo non implica che sia la scelta ottima per i desideri dell'utente; l'acquisto di un trasporto tramite una compagnia di noleggio con autista viene implementato in maniera molto basilare ed \u00e8 sempre in grado di soddisfare le richieste di prenotazione da parte di ACMESky . Struttura del sito Il seguente sito \u00e8 strutturato come segue: Coreografie : descrizione delle coreografie da noi progettate, la verifica della loro connectedness e le loro proiezioni sui diversi ruoli; Coreografie BPMN : descrizione delle coreografie della precedente sezione mediante coreografie BPMN; BPMN : descrizione delle coreografie sotto forma di diagrammi BPMN; UML : descrizione della SOA tramite diagrammi UML con profilo TinySOA; Servizi web : presentazione delle interfacce tramite cui \u00e8 possibile contattare i servizi web dei diversi partecipanti del sistema realizzato; Implementazione : descrizione dei processi e delle decisioni con cui si \u00e8 passati dalla progettazione all'implementazione; Istruzioni per l'esecuzione : descrizione esaustiva su come passare dal codice sorgente del progetto al sistema in esecuzione, passo dopo passo.","title":"Home"},{"location":"#acmesky-documentazione-progetto","text":"Il seguente report descrive i processi che hanno portato alla realizzazione del progetto didattico del corso Ingegneria del Software Orientata ai Servizi della LM Informatica dell'Universit\u00e0 di Bologna, svolto da Marco Ferrati e Tommaso Azzalin nell'A.A. 2020/2021.","title":"ACMESky - Documentazione progetto"},{"location":"#descrizione-del-progetto","text":"Realizzare una Service Oriented Architecture ( SOA ) che rappresenti la realt\u00e0 di una compagnia chiamata ACMESky . ACMESky fornisce ai propri utenti la possibilit\u00e0 di venire notificati e successivamente acquistare offerte di voli A/R in determinate date e al di sotto di una certa soglia di prezzo, da loro scelte in precedenza. ACMESky si relaziona con diversi servizi esterni all'organizzazione: le compagnie aeree (o Flight Company ) per il controllo della presenza di offerte e l'acquisto dei voli; le compagnie di noleggio con autista , da noi rinominate in compagnie di trasporto (o Travel Company ), per la prenotazione del trasporto gratuito degli utenti da casa all'aeroporto e viceversa; il servizio per il calcolo delle distanze geografiche (o Geographical Distances ); il sistema bancario, da noi rinominato in provider di pagamenti (o Payment Provider ), che si occupa di gestire i pagamenti per l'acquisto dei voli da parte degli utenti; il servizio ProntoGram , con il quale contattare gli utenti per comunicar loro i codici delle offerte.","title":"Descrizione del progetto"},{"location":"#assunzioni-e-semplificazioni","text":"Essendo un progetto a scopo didattico sono state adottate alcune assunzioni e semplificazioni sul funzionamento dei vari servizi, che vengono elencati di seguito: gli aspetti relativi alla sicurezza delle comunicazioni e dei dati sono stati ignorati mentre, ad esempio, sarebbe stato corretto utilizzare il protocollo HTTPS per le comunicazioni, gestire l'autenticazione degli utenti su ProntoGram , separare i dati in diverse tabelle e cifrare quelli personali; i voli offerti dalle compagnie aeree sono tutti diretti e quando vengono assegnati ad un offerta ACMESky chiede di riservare un posto alle compagnie aeree in modo da evitare, al momento dell'acquisto, un errore dovuto alla mancanza di disponibilit\u00e0 di posti a sedere; un'offerta di viaggio \u00e8 composta di solo due voli di un'unica compagnia aerea , quelli con prezzo inferiore in tutto il range di date indicato dall'utente, questo non implica che sia la scelta ottima per i desideri dell'utente; l'acquisto di un trasporto tramite una compagnia di noleggio con autista viene implementato in maniera molto basilare ed \u00e8 sempre in grado di soddisfare le richieste di prenotazione da parte di ACMESky .","title":"Assunzioni e semplificazioni"},{"location":"#struttura-del-sito","text":"Il seguente sito \u00e8 strutturato come segue: Coreografie : descrizione delle coreografie da noi progettate, la verifica della loro connectedness e le loro proiezioni sui diversi ruoli; Coreografie BPMN : descrizione delle coreografie della precedente sezione mediante coreografie BPMN; BPMN : descrizione delle coreografie sotto forma di diagrammi BPMN; UML : descrizione della SOA tramite diagrammi UML con profilo TinySOA; Servizi web : presentazione delle interfacce tramite cui \u00e8 possibile contattare i servizi web dei diversi partecipanti del sistema realizzato; Implementazione : descrizione dei processi e delle decisioni con cui si \u00e8 passati dalla progettazione all'implementazione; Istruzioni per l'esecuzione : descrizione esaustiva su come passare dal codice sorgente del progetto al sistema in esecuzione, passo dopo passo.","title":"Struttura del sito"},{"location":"bpmn/","text":"In questa sezione vengono rappresentati, sotto forma di diagrammi BPMN, le coreografie discusse nelle Coreografie, ruoli e proiezioni delle coreografie sui ruoli e BPMN . Per ogni diagramma descriviamo prima il processo ad alto livello, ovvero a scopo documentativo, nel quale mostriamo principalmente il cosiddetto happy path ; successivamente lo espandiamo aggiungendo la gestione degli errori, delle eccezioni e degli altri possibili fallimenti che potrebbero avvenire calando nella realt\u00e0 il processo di business definito. Registrazione interesse di un utente Scopo documentativo Processo di registrazione di un interesse da parte di un utente (scopo documentativo) Il diagramma descrive il processo di registrazione dell'interesse nel portale web di ACMESky , da parte di utente, di un pacchetto di viaggio A/R, con un massimo budget e un range di date entro cui effettuare entrambe le tratte. Il processo inizia con la ricezione da parte di ACMESky di questi dati che vengono successivamente memorizzati da ACMESky per i successivi controlli. Sia che l'operazione avvenga correttamente, sia che essa fallisca, viene comunicato all'utente l'esito di quest'ultima. Il processo pu\u00f2 quindi terminare. Scopo implementativo Il diagramma con scopo implementativo non ha subito modifiche in quanto il processo non prevede la possibilit\u00e0 di fallimento (dal punto di vista del business process). Verifica giornaliera delle offerte Scopo documentativo Processo di verifica giornaliera delle offerte delle compagnie aeree (scopo documentativo) Il diagramma descrive il processo di verifica quotidiana della presenza di offerte che possano soddisfare gli interessi registrati degli utenti di ACMESky . Questo processo si avvia sistematicamente ogni 24 ore. ACMESky contatta i servizi delle compagnie aeree, in modo parallelo, che inviano tutte le offerte a disposizione in quella giornata. Info Ogni istanza del sotto-processo Controllo offerte compagnie aeree si riferisce a una differente compagnia aerea. Nel diagramma questo \u00e8 modellato come se fosse un'unica compagnia poich\u00e9 il modellatore Camunda Modeler non supporta collapsed pool multi-instance . Ricevute le offerte del giorno di una compagnia aerea, vengono memorizzate per effettuare i successivi controlli. Quando sono terminate tutte le istanze del sotto-processo Controllo offerte compagnie aeree , il processo genitore pu\u00f2 continuare nella sua esecuzione. Per ogni utente che ha registrato uno o pi\u00f9 interessi viene avviato, in parallelo, un'istanza del sotto-processo Notifica presenza offerte agli utenti , in cui viene verificata la presenza di una corrispondenza con offerte di voli ricevuti dalle compagnie aeree. In caso non venga trovata alcuna corrispondenza, il sotto-processo termina. Se invece viene trovata, ACMESky genera un codice offerta da inviare all'utente tramite ProntoGram: ACMESky invia il messaggio a ProntoGram , il quale si occuper\u00e0 di inviarlo al client ProntoGram dell'utente. Terminate tutte le istanze parallele di Notifica presenza offerte agli utenti , il processo termina. Scopo implementativo Processo di verifica giornaliera delle offerte delle compagnie aeree (scopo implementativo) Il processo in esame ha subito diverse modifiche per poterlo rendere robusto agli errori che potrebbero verificarsi durante l'esecuzione. In particolare: sono stati aggiunti dei Timer Boundary Event in quei task in cui viene contattato, attraverso la rete, un servizio esterno ad ACMESky : serve ad evitare che, in caso i servizi esterni non riescano ad elaborare la richiesta in tempi ragionevoli, il processo non rimanga altrettanto in stallo; dovendo memorizzare dei voli ottenuti da una compagnia aerea , il salvataggio potrebbe fallire nel caso il formato dei dati ricevuti sia diverso da quello atteso oppure se vengono ricevuti dati duplicati. In questi casi, l'istanza corrente del sotto-processo Controllo offerte compagnie aeree termina senza salvare le offerte di tale compagnia aerea ; \u00e8 stato aggiunto il task Recupero interessi utenti per poter recuperare dalla base di dati gli interessi degli utenti in modo da poterli memorizzare come variabili di Camunda e quindi poter istanziare i diversi sotto-processi Notifica presenza offerte agli utenti . Ricezione offerte last minute Scopo documentativo Processo di ricezione delle offerte last minute (scopo documentativo) Il diagramma descrive il processo di ricezione da parte di ACMESky di un'offerta last minute di una compagnia aerea e la conseguente verifica della presenza di utenti che hanno segnalato il loro interesse verso quel tipo di offerta. Il processo si avvia automaticamente alla ricezione dell'offerta. Quando ACMESky recepisce l'offerta, questa viene memorizzata per effettuare i successivi controlli. Come nel diagramma del processo di Verifica giornaliera delle offerte , per ogni utente che ha registrato uno o pi\u00f9 interessi viene avviata, in parallelo, un'istanza del sotto-processo Notifica presenza offerte agli utenti , in cui viene verificata la presenza di una corrispondenza con offerte di voli ricevuti dalle compagnie aeree. In caso non venga trovata alcuna corrispondenza, il sotto-processo termina. Se invece viene trovata, ACMESky genera un codice offerta da inviare all'utente tramite ProntoGram: ACMESky invia il messaggio a ProntoGram, il quale si occuper\u00e0 di inviarlo al client ProntoGram dell'utente. Terminate tutte le istanze parallele di Notifica presenza offerte agli utenti , il processo termina. Scopo implementativo Processo di ricezione delle offerte last minute (scopo implementativo) Essendo molto simile al precedente business process descritto, anche quest'ultimo ha subito simili modifiche, per cui: \u00e8 stato aggiunto un Timer Boundary Event nel task Invia notifica presenza offerte , che contatta ProntoGram: nel caso in cui il servizio contattato non fosse in grado di soddisfare la richiesta entro i tempi stabiliti, l'istanza del sotto-processo terminerebbe; dovendo memorizzare i voli ottenuti dalla compagnia aerea che ha contattato ACMESky e ha fatto avviare il processo, il salvataggio potrebbe fallire nel caso il formato dei dati ricevuti sia diverso da quello atteso oppure se vengono ricevuti dati duplicati. In questi casi, il processo fallirebbe nel suo intero; \u00e8 stato aggiunto il task Recupero interessi utenti per poter recuperare dalla base di dati gli interessi degli utenti in modo da poterli memorizzare come variabili di Camunda e quindi poter istanziare i diversi sotto-processi Notifica presenza offerte agli utenti . Acquisto offerta da un utente Scopo documentativo Processo di acquisto di un'offerta (scopo documentativo) Il diagramma descrive il processo di acquisto di un offerta da parte di un utente. Il processo inizia con la ricezione, attraverso il portale web di ACMESky , di un codice offerta e dei dati personali dell'utente (nome, cognome, indirizzo). Viene verificata la validit\u00e0 del codice tramite un Service Task e, in caso esso non sia valido, viene avvisato l'utente e il processo termina. Invece, nel caso sia valido, il processo prosegue facendo richiesta al Provider dei Pagamenti di richiedere il pagamento all'utente, il quale gli invia i dati per il pagamento. Quest'ultimo, una volta elaborati tali dati, invia l'esito della transazione ad ACMESky . In caso l'esito della transazione sia negativo, ACMESky comunica all'utente che c'\u00e8 stato un problema con il pagamento e il processo termina; in caso di esito positivo il processo procede nell'esecuzione. ACMESky acquista i biglietti aerei dell'offerta attraverso il servizio della compagnia aerea , la quale restituisce ad ACMESky i biglietti. In caso il prezzo totale dei viaggi superi i 1000 \u20ac e il cliente viva entro 30 Km dall'aeroporto, ACMESky identifica la compagnia di trasporto con autista pi\u00f9 vicina all'abitazione del cliente per prenotare il trasferimento da/verso l'aeroporto. Il calcolo delle distanze viene fatto tramite il servizio Distanze Geografiche . Infine, ACMESky invia all'utente i biglietti aerei e, in caso sia stato prenotato, i biglietti per il trasferimento da/verso l'aeroporto. Il processo pu\u00f2 quindi concludersi. Scopo implementativo Processo di acquisto di un'offerta (scopo implementativo) Il processo appena descritto ha subito numerose modifiche integrative nella sua prima met\u00e0, ovvero quella corrispondente agli step che portano dalla ricezione dei dati al pagamento dell'offerta e della sua conferma. Vengono elencati di seguito: \u00e8 stato introdotto il Transaction Sub-process Verifica codice e validit\u00e0 del pagamento che racchiude tutti i task relativi alla verifica del codice offerta inserito e del pagamento. Nel caso di fallimento del sotto-processo, anche il processo genitore termina, non prima per\u00f2 di aver ripristinato lo stato del sistema riabilitando il codice dell'offerta (che torna utilizzabile) attraverso la Compensating action Riabilita codice offerta ; \u00e8 stato inserito, come nei precedenti diagrammi, un Timer Boundary Event, per gestire il caso in cui il Provider dei Pagamenti non risponda nei tempi previsti; \u00e8 stato inserito, successivamente all'invio della richiesta di pagamento al Provider dei Pagamenti da parte di ACMESky , un Event-based gateway con lo scopo di ricevere o la ricezione dell'esito del pagamento da parte del gestore dei pagamenti oppure della scadenza di un timeout nel caso in cui l'utente non paghi entro 10 minuti.","title":"BPMN"},{"location":"bpmn/#registrazione-interesse-di-un-utente","text":"","title":"Registrazione interesse di un utente"},{"location":"bpmn/#scopo-documentativo","text":"Processo di registrazione di un interesse da parte di un utente (scopo documentativo) Il diagramma descrive il processo di registrazione dell'interesse nel portale web di ACMESky , da parte di utente, di un pacchetto di viaggio A/R, con un massimo budget e un range di date entro cui effettuare entrambe le tratte. Il processo inizia con la ricezione da parte di ACMESky di questi dati che vengono successivamente memorizzati da ACMESky per i successivi controlli. Sia che l'operazione avvenga correttamente, sia che essa fallisca, viene comunicato all'utente l'esito di quest'ultima. Il processo pu\u00f2 quindi terminare.","title":"Scopo documentativo"},{"location":"bpmn/#scopo-implementativo","text":"Il diagramma con scopo implementativo non ha subito modifiche in quanto il processo non prevede la possibilit\u00e0 di fallimento (dal punto di vista del business process).","title":"Scopo implementativo"},{"location":"bpmn/#verifica-giornaliera-delle-offerte","text":"","title":"Verifica giornaliera delle offerte"},{"location":"bpmn/#scopo-documentativo_1","text":"Processo di verifica giornaliera delle offerte delle compagnie aeree (scopo documentativo) Il diagramma descrive il processo di verifica quotidiana della presenza di offerte che possano soddisfare gli interessi registrati degli utenti di ACMESky . Questo processo si avvia sistematicamente ogni 24 ore. ACMESky contatta i servizi delle compagnie aeree, in modo parallelo, che inviano tutte le offerte a disposizione in quella giornata. Info Ogni istanza del sotto-processo Controllo offerte compagnie aeree si riferisce a una differente compagnia aerea. Nel diagramma questo \u00e8 modellato come se fosse un'unica compagnia poich\u00e9 il modellatore Camunda Modeler non supporta collapsed pool multi-instance . Ricevute le offerte del giorno di una compagnia aerea, vengono memorizzate per effettuare i successivi controlli. Quando sono terminate tutte le istanze del sotto-processo Controllo offerte compagnie aeree , il processo genitore pu\u00f2 continuare nella sua esecuzione. Per ogni utente che ha registrato uno o pi\u00f9 interessi viene avviato, in parallelo, un'istanza del sotto-processo Notifica presenza offerte agli utenti , in cui viene verificata la presenza di una corrispondenza con offerte di voli ricevuti dalle compagnie aeree. In caso non venga trovata alcuna corrispondenza, il sotto-processo termina. Se invece viene trovata, ACMESky genera un codice offerta da inviare all'utente tramite ProntoGram: ACMESky invia il messaggio a ProntoGram , il quale si occuper\u00e0 di inviarlo al client ProntoGram dell'utente. Terminate tutte le istanze parallele di Notifica presenza offerte agli utenti , il processo termina.","title":"Scopo documentativo"},{"location":"bpmn/#scopo-implementativo_1","text":"Processo di verifica giornaliera delle offerte delle compagnie aeree (scopo implementativo) Il processo in esame ha subito diverse modifiche per poterlo rendere robusto agli errori che potrebbero verificarsi durante l'esecuzione. In particolare: sono stati aggiunti dei Timer Boundary Event in quei task in cui viene contattato, attraverso la rete, un servizio esterno ad ACMESky : serve ad evitare che, in caso i servizi esterni non riescano ad elaborare la richiesta in tempi ragionevoli, il processo non rimanga altrettanto in stallo; dovendo memorizzare dei voli ottenuti da una compagnia aerea , il salvataggio potrebbe fallire nel caso il formato dei dati ricevuti sia diverso da quello atteso oppure se vengono ricevuti dati duplicati. In questi casi, l'istanza corrente del sotto-processo Controllo offerte compagnie aeree termina senza salvare le offerte di tale compagnia aerea ; \u00e8 stato aggiunto il task Recupero interessi utenti per poter recuperare dalla base di dati gli interessi degli utenti in modo da poterli memorizzare come variabili di Camunda e quindi poter istanziare i diversi sotto-processi Notifica presenza offerte agli utenti .","title":"Scopo implementativo"},{"location":"bpmn/#ricezione-offerte-last-minute","text":"","title":"Ricezione offerte last minute"},{"location":"bpmn/#scopo-documentativo_2","text":"Processo di ricezione delle offerte last minute (scopo documentativo) Il diagramma descrive il processo di ricezione da parte di ACMESky di un'offerta last minute di una compagnia aerea e la conseguente verifica della presenza di utenti che hanno segnalato il loro interesse verso quel tipo di offerta. Il processo si avvia automaticamente alla ricezione dell'offerta. Quando ACMESky recepisce l'offerta, questa viene memorizzata per effettuare i successivi controlli. Come nel diagramma del processo di Verifica giornaliera delle offerte , per ogni utente che ha registrato uno o pi\u00f9 interessi viene avviata, in parallelo, un'istanza del sotto-processo Notifica presenza offerte agli utenti , in cui viene verificata la presenza di una corrispondenza con offerte di voli ricevuti dalle compagnie aeree. In caso non venga trovata alcuna corrispondenza, il sotto-processo termina. Se invece viene trovata, ACMESky genera un codice offerta da inviare all'utente tramite ProntoGram: ACMESky invia il messaggio a ProntoGram, il quale si occuper\u00e0 di inviarlo al client ProntoGram dell'utente. Terminate tutte le istanze parallele di Notifica presenza offerte agli utenti , il processo termina.","title":"Scopo documentativo"},{"location":"bpmn/#scopo-implementativo_2","text":"Processo di ricezione delle offerte last minute (scopo implementativo) Essendo molto simile al precedente business process descritto, anche quest'ultimo ha subito simili modifiche, per cui: \u00e8 stato aggiunto un Timer Boundary Event nel task Invia notifica presenza offerte , che contatta ProntoGram: nel caso in cui il servizio contattato non fosse in grado di soddisfare la richiesta entro i tempi stabiliti, l'istanza del sotto-processo terminerebbe; dovendo memorizzare i voli ottenuti dalla compagnia aerea che ha contattato ACMESky e ha fatto avviare il processo, il salvataggio potrebbe fallire nel caso il formato dei dati ricevuti sia diverso da quello atteso oppure se vengono ricevuti dati duplicati. In questi casi, il processo fallirebbe nel suo intero; \u00e8 stato aggiunto il task Recupero interessi utenti per poter recuperare dalla base di dati gli interessi degli utenti in modo da poterli memorizzare come variabili di Camunda e quindi poter istanziare i diversi sotto-processi Notifica presenza offerte agli utenti .","title":"Scopo implementativo"},{"location":"bpmn/#acquisto-offerta-da-un-utente","text":"","title":"Acquisto offerta da un utente"},{"location":"bpmn/#scopo-documentativo_3","text":"Processo di acquisto di un'offerta (scopo documentativo) Il diagramma descrive il processo di acquisto di un offerta da parte di un utente. Il processo inizia con la ricezione, attraverso il portale web di ACMESky , di un codice offerta e dei dati personali dell'utente (nome, cognome, indirizzo). Viene verificata la validit\u00e0 del codice tramite un Service Task e, in caso esso non sia valido, viene avvisato l'utente e il processo termina. Invece, nel caso sia valido, il processo prosegue facendo richiesta al Provider dei Pagamenti di richiedere il pagamento all'utente, il quale gli invia i dati per il pagamento. Quest'ultimo, una volta elaborati tali dati, invia l'esito della transazione ad ACMESky . In caso l'esito della transazione sia negativo, ACMESky comunica all'utente che c'\u00e8 stato un problema con il pagamento e il processo termina; in caso di esito positivo il processo procede nell'esecuzione. ACMESky acquista i biglietti aerei dell'offerta attraverso il servizio della compagnia aerea , la quale restituisce ad ACMESky i biglietti. In caso il prezzo totale dei viaggi superi i 1000 \u20ac e il cliente viva entro 30 Km dall'aeroporto, ACMESky identifica la compagnia di trasporto con autista pi\u00f9 vicina all'abitazione del cliente per prenotare il trasferimento da/verso l'aeroporto. Il calcolo delle distanze viene fatto tramite il servizio Distanze Geografiche . Infine, ACMESky invia all'utente i biglietti aerei e, in caso sia stato prenotato, i biglietti per il trasferimento da/verso l'aeroporto. Il processo pu\u00f2 quindi concludersi.","title":"Scopo documentativo"},{"location":"bpmn/#scopo-implementativo_3","text":"Processo di acquisto di un'offerta (scopo implementativo) Il processo appena descritto ha subito numerose modifiche integrative nella sua prima met\u00e0, ovvero quella corrispondente agli step che portano dalla ricezione dei dati al pagamento dell'offerta e della sua conferma. Vengono elencati di seguito: \u00e8 stato introdotto il Transaction Sub-process Verifica codice e validit\u00e0 del pagamento che racchiude tutti i task relativi alla verifica del codice offerta inserito e del pagamento. Nel caso di fallimento del sotto-processo, anche il processo genitore termina, non prima per\u00f2 di aver ripristinato lo stato del sistema riabilitando il codice dell'offerta (che torna utilizzabile) attraverso la Compensating action Riabilita codice offerta ; \u00e8 stato inserito, come nei precedenti diagrammi, un Timer Boundary Event, per gestire il caso in cui il Provider dei Pagamenti non risponda nei tempi previsti; \u00e8 stato inserito, successivamente all'invio della richiesta di pagamento al Provider dei Pagamenti da parte di ACMESky , un Event-based gateway con lo scopo di ricevere o la ricezione dell'esito del pagamento da parte del gestore dei pagamenti oppure della scadenza di un timeout nel caso in cui l'utente non paghi entro 10 minuti.","title":"Scopo implementativo"},{"location":"coreografie/","text":"div.choreographies ul li, div.projections ul li { list-style-type: none; } div.choreographies ul, div.projections ul { margin: 0px; } Coreografie, ruoli e proiezioni delle coreografie sui ruoli Coreografie Le seguenti coreografie modellano tutti quanti i possibili processi che possono avvenire nel sistema che verr\u00e0 implementato. Le interazioni che non comprendono ACMESky come mittente o destinatario sono molto semplificate, in quanto esterne ad essa e di cui non possiamo conoscere l'implementazione interna. Verranno utilizzate le seguenti sigle per i ruoli delle coreografie: AS: ACMESky; CA i : Compagnie Aerea i , con i \u2208 {1..N}; CT j : Compagnie Trasporto j , con j \u2208 {1..M}; PG: ProntoGram; PP: Provider dei Pagamenti; DG: servizio per il calcolo delle Distanze Geografiche; UT k : UTente (il range in cui k varia dipende dagli utenti che attualmente hanno registrato interessi presso ACMESky). Registrazione interesse di un utente RegistrazioneInteresseUtente ::= ( reg : UT k -> AS; reg_res : AS -> UT k ) Le interazioni hanno il seguente significato: reg : registrazione dell'interesse di un utente per un viaggio; reg_res : risposta all'interazione reg (conferma o smentita della registrazione). Verifica giornaliera delle offerte VerificaGiornaliera ::= ( ( control : AS -> CA 1 ; control_res : CA 1 -> AS ) | ... | ( control : AS -> CA N ; control_res : CA N -> AS ) ) ; ( ( ( notify : AS -> PG ; message : PG -> UT 1 ) + 1 ) | ... | ( ( notify : AS -> PG ; message : PG -> UT N ) + 1 ) ) Le interazioni hanno il seguente significato: control : controllo giornaliero della presenza di offerte da parte della compagnia aerea ; control_res : risposta all'interazione control (inoltro delle nuove offerte disponibili); notify : notifica della presenza di voli di interesse per l'utente tramite ProntoGram (possono esserci come no, se non ci sono l'utente non viene contattato). Il codice offerta inviato \u00e8 univoco per offerta: se ci sono pi\u00f9 utenti con gli stessi interessi viene inviato lo stesso codice offerta; message : ProntoGram riferisce il messaggio all'utente (essendo un servizio esterno questa \u00e8 una semplificazione). Ricezione offerte last minute NotificaVoliLastMinute ::= ( last_minute : CA i -> AS ) ; ( ( ( notify : AS -> PG ; message : PG -> UT 1 ) + 1 ) | ... | ( ( notify : AS -> PG ; message : PG -> UT N ) + 1 ) ) Le interazioni hanno il seguente significato: last_minute : la compagnia aerea notifica ACMESky della presenza di alcune offerte last minute, inviandogliele; notify : notifica della presenza di voli di interesse per l'utente tramite ProntoGram (possono esserci come no, se non ci sono l'utente non viene contattato). Il codice offerta inviato \u00e8 univoco per offerta: se ci sono pi\u00f9 utenti con gli stessi interessi viene inviato lo stesso codice offerta; message : ProntoGram riferisce il messaggio all'utente (essendo un servizio esterno questa \u00e8 una semplificazione). Acquisto offerta da un utente AcquistoOfferta ::= ( ins_code : UT k -> AS ; ins_code_res : AS -> UT k ) ; ( ( req_pay : AS -> PP ; req_pay_res : PP -> AS ; send_payment_ref : AS -> UT k ; pay_offer : UT k -> PP ; ( pay_offer_res PP -> UT k | send_payment_status : PP -> AS ) ) ; ( ( buy_flights : AS -> CA i ; buy_flights_res : CA i -> AS ) ; ( ( ( calc_dist : AS -> DG ; calc_dist_res : DG -> AS ) ; ( ( calc_dist : AS -> DG ; calc_dist_res : DG -> AS ) * ; ( pren_trs : AS -> CT j ; pren_trs_res : CT j -> AS) ) + 1 ) + 1 ); send_tickets : AS -> UT k ) + payment_failure : AS -> UT k ) + ins_code_failure : AS -> UT k Le interazioni hanno il seguente significato: ins_code : l'utente inserisce il codice ricevuto via ProntoGram sul portale; ins_code_res : risposta all'interazione ins_code (conferma o smentita della ricezione del codice offerta); req_pay : ACMESky richiede il pagamento al Provider dei Pagamenti ; req_pay_res : risposta all'interazione req_pay (inoltro riferimento per il pagamento dell'offerta); send_payment_ref : ACMESky invia all'utente il riferimento per poter pagare l'offerta tramite il Provider dei Pagamenti ; pay_offer : l'utente invia i dati per il pagamento al Provider dei Pagamenti ; pay_offer_res : risposta all'interazione pay_offer (invio esito del pagamento all'utente); send_payment_status : il Provider dei Pagamenti comunica ad ACMESky l'esito del pagamento; buy_flights : ACMESky compra per conto dell'utente il biglietto per i voli scelti presso la compagnia aerea CA i che fornisce entrambi i voli che soddisfano il bisogno; buy_flights_res : risposta all'interazione buy_flights (CA i conferma ad ACMESky la disponibilit\u00e0 del volo e inoltra il biglietto); calc_dist : ACMESky richiede il calcolo della distanza al servizio esterno per il calcolo delle distanze geografiche ; calc_dist_res : risposta all'interazione calc_dist ; pren_trs : in base alla distanza ACMESky pu\u00f2, oppure no, prenotare il trasporto; pren_trs_res : risposta all'interazione pren_trs ; send_tickets : ACMESky invia all'utente i biglietti; payment_failure : ACMESky comunica all'utente che c'\u00e8 stato un problema durante il pagamento; ins_code_failure : ACMESky comunica all'utente che il codice inserito non \u00e8 valido. Verifica della connectedness delle coreografie Registrazione interesse di un utente RegistrazioneInteresseUtente \u00e8 connessa in quanto il ricevente in reg \u00e8 uguale al mittente in reg_res . Verifica giornaliera delle offerte In VerificaGiornaliera , la singola comunicazione fra AS e un qualsiasi CA i \u00e8 connessa come per la precedente coreografia, in quanto il ricevente in control \u00e8 uguale al mittente in control_res . Le interazioni parallele non hanno condizioni per poter verificare la connectedness e quindi non vengono verificate. Per quanto riguarda la composizione sequenziale fra la prima parte della coreografia, in cui avvengono le interazioni ( control ; control_res ) fra AS e le varie CA i , e la seconda parte, in cui avviene l'interazione dei notify fra AS e PG, \u00e8 nuovamente assicurata la connectedness. Questo poich\u00e9 ogni interazione all'interno della composizione parallela termina con ricevente AS e il mittente di ogni notify \u00e8 AS. Dopo notify nella sequenza c'\u00e8 message che invia il messaggio ad UT k . Essendo PG il ricevente di notify e il mittente di message , la sequenza \u00e8 connessa. Nel caso in cui non avvenga notify fra AS e PG poich\u00e9 non vi sono voli per l'utente da comunicare via ProntoGram, allora viene eseguito il ramo \"1\" (ovvero non viene fatto nulla). In questo caso, PG rimane in attesa di notify ma \u00e8 corretto poich\u00e9 \u00e8 il suo compito. Come nell'interazione fra AS e le varie CA i , le interazioni parallele ( ( notify ; message ) + 1 ) non hanno condizioni per verificare la connectedness e quindi non viene verificata. Ricezione offerte last minute NotificaVoliLastMinute \u00e8 connessa in modo non dissimile a quanto avviene in VerificaGiornaliera . AS \u00e8 ricevente in last_minute e mittente in notify , dopodich\u00e9 PG \u00e8 ricevente in notify e mittente in message . Da notare che notify e message , avvengono solamente se ci sono voli di interesse per l'utente e quindi nuovamente, in caso non ce ne siano, ProntoGram resterebbe in attesa ma non sarebbe un problema poich\u00e9 \u00e8 il suo compito. Come nella precedente coreografia, per le interazioni parallele ( ( notify ; message ) + 1 ) non pu\u00f2 essere verificata la connectedness. Acquisto offerta da un utente AcquistoOfferta \u00e8 connessa perch\u00e9: il ricevente di ins_code \u00e8 il mittente di ins_code_res e di ins_code_failure (quest'ultimo termina la coreografia); il mittente di ins_code_res \u00e8 lo stesso mittente di req_pay ; il ricevente di req_pay \u00e8 il mittente di req_pay_res ; il ricevente di req_pay_res \u00e8 il mittente di send_payment_ref ; il ricevente di send_payment_ref \u00e8 il mittente di pay_offer ; il ricevente di pay_offer \u00e8 sia il mittente di pay_offer_res che di send_payment_status e i due riceventi sono diversi (UT k in un caso, AS nell'altro); il ricevente di send_payment_status \u00e8 il mittente di buy_flights e di payment_failure (quest'ultimo termina la coreografia); il ricevente di buy_flights \u00e8 il mittente di buy_flights_res ; il ricevente di buy_flights_res \u00e8 il mittente di calc_dist e di send_tickets (quest'ultimo termina la coreografia); il ricevente di calc_dist \u00e8 il mittente di calc_dist_res (nella sua prima invocazione); il ricevente di calc_dist_res \u00e8 il mittente della seconda invocazione di calc_dist e di send_tickets (quest'ultimo termina la coreografia); il ricevente di calc_dist \u00e8 il mittente di calc_dist_res nella prima parte della sequenza ( calc_dist ; calc_dist_res )* ; il ricevente di calc_dist_res \u00e8 il mittente di calc_dist nella seconda parte della sopracitata sequenza, che quindi \u00e8 connessa; il ricevente di calc_dist_res (l'ultimo della sequenza lunga almeno uno per ipotesi) \u00e8 il mittente di pren_trs ; il ricevente di pren_trs \u00e8 il mittente di pren_trs_res ; il ricevente di pren_trs_res \u00e8 il mittente di send_tickets (quest'ultimo termina la coreografia). Proiezioni Seguono le proiezioni delle coreografie, divise per ruolo. AS (ACMESky) proj( RegistrazioneInteresseUtente , AS) = ( reg @UT k ; reg_res @UT k ) proj( VerificaGiornaliera , AS) = ( ( control @CA 1 ; control_res @CA 1 ) | ... | ( control @CA N ; control_res @CA N ) ) ; ( ( ( notify @PG ; 1 ) + 1 ) | ... | ( ( notify @PG ; 1 ) + 1 ) ) proj( NotificaVoliLastMinute , AS) = ( last_minute @CA i ) ; ( ( ( notify @PG ; 1 ) + 1 ) | ... | ( ( notify @PG ; 1 ) + 1 ) ) proj( AcquistoOfferta , AS) = ( ins_code @UT k ; ins_code_res @UT k ) ; ( ( req_pay @PP ; req_pay_res @PP ; send_payment_ref @UT k ; 1 ; ( 1 | send_payment_status @PP ) ; ( ( buy_flights @CA i ; buy_flights_res @CA i ) ; ( ( ( calc_dist @DG ; calc_dist_res @DG ) ; ( ( calc_dist @DG ; calc_dist_res @DG ) * ( pren_trs @CT j ; pren_trs_res @CT j ) ) + 1 ) + 1 ); send_tickets @UT k ) + payment_failure @UT k ) + ins_code_failure @UT k UT k (UTente) proj( RegistrazioneInteresseUtente , UT k ) = ( reg @AS ; reg_res @AS ) proj( VerificaGiornaliera , UT k ) = ( ( 1 ; 1 ) | ... | ( 1 ; 1 ) ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; message @PG ) + 1) | ... | ( ( 1 ; 1 ) + 1 ) ) = message @PG proj( NotificaVoliLastMinute , UT k ) = ( 1 ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; message @PG ) + 1) | ... | ( ( 1 ; 1 ) + 1 ) ) = message @PG proj( AcquistoOfferta , UT k ) = ( ins_code @AS ; ins_code_res @AS ) ; ( ( 1 ; 1 ; send_payment_ref @AS ; pay_offer @PP ; ( pay_offer_res @PP | 1 ) ) ; ( ( 1 ; 1 ) ; ( ( ( 1 ; 1 ) ( ( 1 ; 1 ) * ( 1 ; 1 ) ) + 1 ) + 1 ) ; send_tickets @AS ) + payment_failure @AS ) + ins_code_failure @AS = ( ins_code @AS ; ins_code_res @AS ) ; ( send_payment_ref @AS ; pay_offer @PP ; pay_offer_res @PP ) ; DG (Distanze Geografiche) proj( RegistrazioneInteresseUtente , DG) = ( 1 ; 1 ) = 1 proj( VerificaGiornaliera , DG) = ( (1 ; 1) | ... | ( 1 ; 1 ) ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; 1 ) + 1 ) ) = 1 proj( NotificaVoliLastMinute , DG) = ( 1 ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; 1 ) + 1 ) ) = 1 proj( AcquistoOfferta , DG) = ( 1 ; 1 ) ; ( ( 1 ; 1 ; 1 ; 1 ; ( 1 | 1 ) ) ; ( ( 1 ; 1 ) ; ( ( ( calc_dist @AS ; calc_dist_res @AS ) ; ( ( calc_dist @AS ; calc_dist_res @AS ) * ( 1 ; 1 ) ) + 1 ) + 1 ); + 1 ) + 1 ) + 1 = ( calc_dist @AS ; calc_dist_res @AS ) ; ( calc_dist @AS ; calc_dist_res @AS ) * ) + 1 PP (Provider dei Pagamenti) proj( RegistrazioneInteresseUtente , PP) = ( 1 ; 1 ) = 1 proj( VerificaGiornaliera , PP) = ( ( 1 ; 1 ) | ... | ( 1 ; 1 ) ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; 1 ) + 1 ) ) = 1 proj( NotificaVoliLastMinute , PP) = ( 1 ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; 1 ) + 1 ) ) = 1 proj( AcquistoOfferta , PP) = ( 1 ; 1 ) ; ( ( req_pay @AS ; req_pay_res @AS ; 1 ; pay_offer @UT k ; ( pay_offer_res @UT k | send_payment_status @AS ) ) ; ( ( 1 ; 1 ) ; ( ( ( 1 ; 1 ) ; ( ( 1 ; 1 ) * ( 1 ; 1 ) ) + 1 ) + 1 ); + 1 ) + 1 ) + 1 = ( req_pay @AS ; req_pay_res @AS ; pay_offer @UT k ; ( pay_offer_res @UT k | send_payment_status @AS ) ) PG (ProntoGram) proj( RegistrazioneInteresseUtente , PG) = ( 1 ; 1 ) = 1 proj( VerificaGiornaliera , PG) = ( ( 1 ; 1 ) | ... | ( 1 ; 1 ) ) ; ( ( ( notify @AS ; message @UT 1 ) + 1 ) | ... | ( ( notify @AS ; message @UT N ) + 1 ) ) = ( ( notify @AS ; message @UT 1 ) + 1 ) | ... | ( notify @AS ; message @UT k ) | ... | ( ( notify @AS ; message @UT N ) + 1 ) proj( NotificaVoliLastMinute , PG) = ( 1 ) ; ( ( ( notify @AS ; message @UT 1 ) + 1 ) | ... | ( ( notify @AS ; message @UT N ) + 1 ) ) = ( ( notify @AS ; message @UT 1 ) + 1 ) | ... | ( notify @AS ; message @UT k ) | ... | ( ( notify @AS ; message @UT N ) + 1 ) proj( AcquistoOfferta , PG) = ( 1 ; 1 ) ; ( ( 1 ; 1 ; 1 ; 1 ; ( 1 | 1 ) ) ; ( ( 1 ; 1 ) ; ( ( ( 1 ; 1 ) ; ( ( 1 ; 1 ) * ( 1 ; 1 ) ) + 1 ) + 1 ); + 1 ) + 1 ) + 1 = 1 CT j (Compagnia Trasporti) proj( RegistrazioneInteresseUtente , CT j ) = ( 1 ; 1 ) = 1 proj( VerificaGiornaliera , CT j ) = ( ( 1 ; 1 ) | ... | ( 1 ; 1 ) ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; 1 ) + 1 ) ) = 1 proj( NotificaVoliLastMinute , CT j ) = ( 1 ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; 1 ) + 1 ) ) = 1 proj( AcquistoOfferta , CT j ) = ( 1 ; 1 ) ; ( ( 1 ; 1 ; 1 ; 1 ; ( 1 | 1 ) ; ( ( 1 ; 1 ) ; ( ( ( 1 ; 1 ) ; ( ( 1 ; 1 ) * ( pren_trs @AS; pren_trs_res @AS ) ) + 1 ) + 1 ); + 1 ) + 1 ) + 1 = ( pren_trs @AS; pren_trs_res @AS ) CA i (Compagnia Aerea) proj( RegistrazioneInteresseUtente , CA i ) = ( 1 ; 1 ) = 1 proj( VerificaGiornaliera , CA i ) = ( (1 ; 1) | ... | ( control @AS ; control_res @AS ) | ... | ( 1 ; 1 ) ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; 1 ) + 1 ) ) = ( control @AS ; control_res @AS ) proj( NotificaVoliLastMinute , CA i ) = ( last_minute @AS ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; 1 ) + 1 ) ) = last_minute @AS proj( AcquistoOfferta , CA i ) = ( 1 ; 1 ) ; ( ( 1 ; 1 ; 1 ; 1 ; ( 1 | 1 )) ; ( ( buy_flights @AS ; buy_flights_res @CA ) ; ( ( ( 1 ; 1 ) ; ( ( 1 ; 1 ) * ( 1 ; 1 ) ) + 1 ) + 1 ); + 1 ) + 1 ) + 1 = ( buy_flights @AS ; buy_flights_res @CA )","title":"Coreografie"},{"location":"coreografie/#coreografie-ruoli-e-proiezioni-delle-coreografie-sui-ruoli","text":"","title":"Coreografie, ruoli e proiezioni delle coreografie sui ruoli"},{"location":"coreografie/#coreografie","text":"Le seguenti coreografie modellano tutti quanti i possibili processi che possono avvenire nel sistema che verr\u00e0 implementato. Le interazioni che non comprendono ACMESky come mittente o destinatario sono molto semplificate, in quanto esterne ad essa e di cui non possiamo conoscere l'implementazione interna. Verranno utilizzate le seguenti sigle per i ruoli delle coreografie: AS: ACMESky; CA i : Compagnie Aerea i , con i \u2208 {1..N}; CT j : Compagnie Trasporto j , con j \u2208 {1..M}; PG: ProntoGram; PP: Provider dei Pagamenti; DG: servizio per il calcolo delle Distanze Geografiche; UT k : UTente (il range in cui k varia dipende dagli utenti che attualmente hanno registrato interessi presso ACMESky).","title":"Coreografie"},{"location":"coreografie/#registrazione-interesse-di-un-utente","text":"RegistrazioneInteresseUtente ::= ( reg : UT k -> AS; reg_res : AS -> UT k ) Le interazioni hanno il seguente significato: reg : registrazione dell'interesse di un utente per un viaggio; reg_res : risposta all'interazione reg (conferma o smentita della registrazione).","title":"Registrazione interesse di un utente"},{"location":"coreografie/#verifica-giornaliera-delle-offerte","text":"VerificaGiornaliera ::= ( ( control : AS -> CA 1 ; control_res : CA 1 -> AS ) | ... | ( control : AS -> CA N ; control_res : CA N -> AS ) ) ; ( ( ( notify : AS -> PG ; message : PG -> UT 1 ) + 1 ) | ... | ( ( notify : AS -> PG ; message : PG -> UT N ) + 1 ) ) Le interazioni hanno il seguente significato: control : controllo giornaliero della presenza di offerte da parte della compagnia aerea ; control_res : risposta all'interazione control (inoltro delle nuove offerte disponibili); notify : notifica della presenza di voli di interesse per l'utente tramite ProntoGram (possono esserci come no, se non ci sono l'utente non viene contattato). Il codice offerta inviato \u00e8 univoco per offerta: se ci sono pi\u00f9 utenti con gli stessi interessi viene inviato lo stesso codice offerta; message : ProntoGram riferisce il messaggio all'utente (essendo un servizio esterno questa \u00e8 una semplificazione).","title":"Verifica giornaliera delle offerte"},{"location":"coreografie/#ricezione-offerte-last-minute","text":"NotificaVoliLastMinute ::= ( last_minute : CA i -> AS ) ; ( ( ( notify : AS -> PG ; message : PG -> UT 1 ) + 1 ) | ... | ( ( notify : AS -> PG ; message : PG -> UT N ) + 1 ) ) Le interazioni hanno il seguente significato: last_minute : la compagnia aerea notifica ACMESky della presenza di alcune offerte last minute, inviandogliele; notify : notifica della presenza di voli di interesse per l'utente tramite ProntoGram (possono esserci come no, se non ci sono l'utente non viene contattato). Il codice offerta inviato \u00e8 univoco per offerta: se ci sono pi\u00f9 utenti con gli stessi interessi viene inviato lo stesso codice offerta; message : ProntoGram riferisce il messaggio all'utente (essendo un servizio esterno questa \u00e8 una semplificazione).","title":"Ricezione offerte last minute"},{"location":"coreografie/#acquisto-offerta-da-un-utente","text":"AcquistoOfferta ::= ( ins_code : UT k -> AS ; ins_code_res : AS -> UT k ) ; ( ( req_pay : AS -> PP ; req_pay_res : PP -> AS ; send_payment_ref : AS -> UT k ; pay_offer : UT k -> PP ; ( pay_offer_res PP -> UT k | send_payment_status : PP -> AS ) ) ; ( ( buy_flights : AS -> CA i ; buy_flights_res : CA i -> AS ) ; ( ( ( calc_dist : AS -> DG ; calc_dist_res : DG -> AS ) ; ( ( calc_dist : AS -> DG ; calc_dist_res : DG -> AS ) * ; ( pren_trs : AS -> CT j ; pren_trs_res : CT j -> AS) ) + 1 ) + 1 ); send_tickets : AS -> UT k ) + payment_failure : AS -> UT k ) + ins_code_failure : AS -> UT k Le interazioni hanno il seguente significato: ins_code : l'utente inserisce il codice ricevuto via ProntoGram sul portale; ins_code_res : risposta all'interazione ins_code (conferma o smentita della ricezione del codice offerta); req_pay : ACMESky richiede il pagamento al Provider dei Pagamenti ; req_pay_res : risposta all'interazione req_pay (inoltro riferimento per il pagamento dell'offerta); send_payment_ref : ACMESky invia all'utente il riferimento per poter pagare l'offerta tramite il Provider dei Pagamenti ; pay_offer : l'utente invia i dati per il pagamento al Provider dei Pagamenti ; pay_offer_res : risposta all'interazione pay_offer (invio esito del pagamento all'utente); send_payment_status : il Provider dei Pagamenti comunica ad ACMESky l'esito del pagamento; buy_flights : ACMESky compra per conto dell'utente il biglietto per i voli scelti presso la compagnia aerea CA i che fornisce entrambi i voli che soddisfano il bisogno; buy_flights_res : risposta all'interazione buy_flights (CA i conferma ad ACMESky la disponibilit\u00e0 del volo e inoltra il biglietto); calc_dist : ACMESky richiede il calcolo della distanza al servizio esterno per il calcolo delle distanze geografiche ; calc_dist_res : risposta all'interazione calc_dist ; pren_trs : in base alla distanza ACMESky pu\u00f2, oppure no, prenotare il trasporto; pren_trs_res : risposta all'interazione pren_trs ; send_tickets : ACMESky invia all'utente i biglietti; payment_failure : ACMESky comunica all'utente che c'\u00e8 stato un problema durante il pagamento; ins_code_failure : ACMESky comunica all'utente che il codice inserito non \u00e8 valido.","title":"Acquisto offerta da un utente"},{"location":"coreografie/#verifica-della-connectedness-delle-coreografie","text":"","title":"Verifica della connectedness delle coreografie"},{"location":"coreografie/#registrazione-interesse-di-un-utente_1","text":"RegistrazioneInteresseUtente \u00e8 connessa in quanto il ricevente in reg \u00e8 uguale al mittente in reg_res .","title":"Registrazione interesse di un utente"},{"location":"coreografie/#verifica-giornaliera-delle-offerte_1","text":"In VerificaGiornaliera , la singola comunicazione fra AS e un qualsiasi CA i \u00e8 connessa come per la precedente coreografia, in quanto il ricevente in control \u00e8 uguale al mittente in control_res . Le interazioni parallele non hanno condizioni per poter verificare la connectedness e quindi non vengono verificate. Per quanto riguarda la composizione sequenziale fra la prima parte della coreografia, in cui avvengono le interazioni ( control ; control_res ) fra AS e le varie CA i , e la seconda parte, in cui avviene l'interazione dei notify fra AS e PG, \u00e8 nuovamente assicurata la connectedness. Questo poich\u00e9 ogni interazione all'interno della composizione parallela termina con ricevente AS e il mittente di ogni notify \u00e8 AS. Dopo notify nella sequenza c'\u00e8 message che invia il messaggio ad UT k . Essendo PG il ricevente di notify e il mittente di message , la sequenza \u00e8 connessa. Nel caso in cui non avvenga notify fra AS e PG poich\u00e9 non vi sono voli per l'utente da comunicare via ProntoGram, allora viene eseguito il ramo \"1\" (ovvero non viene fatto nulla). In questo caso, PG rimane in attesa di notify ma \u00e8 corretto poich\u00e9 \u00e8 il suo compito. Come nell'interazione fra AS e le varie CA i , le interazioni parallele ( ( notify ; message ) + 1 ) non hanno condizioni per verificare la connectedness e quindi non viene verificata.","title":"Verifica giornaliera delle offerte"},{"location":"coreografie/#ricezione-offerte-last-minute_1","text":"NotificaVoliLastMinute \u00e8 connessa in modo non dissimile a quanto avviene in VerificaGiornaliera . AS \u00e8 ricevente in last_minute e mittente in notify , dopodich\u00e9 PG \u00e8 ricevente in notify e mittente in message . Da notare che notify e message , avvengono solamente se ci sono voli di interesse per l'utente e quindi nuovamente, in caso non ce ne siano, ProntoGram resterebbe in attesa ma non sarebbe un problema poich\u00e9 \u00e8 il suo compito. Come nella precedente coreografia, per le interazioni parallele ( ( notify ; message ) + 1 ) non pu\u00f2 essere verificata la connectedness.","title":"Ricezione offerte last minute"},{"location":"coreografie/#acquisto-offerta-da-un-utente_1","text":"AcquistoOfferta \u00e8 connessa perch\u00e9: il ricevente di ins_code \u00e8 il mittente di ins_code_res e di ins_code_failure (quest'ultimo termina la coreografia); il mittente di ins_code_res \u00e8 lo stesso mittente di req_pay ; il ricevente di req_pay \u00e8 il mittente di req_pay_res ; il ricevente di req_pay_res \u00e8 il mittente di send_payment_ref ; il ricevente di send_payment_ref \u00e8 il mittente di pay_offer ; il ricevente di pay_offer \u00e8 sia il mittente di pay_offer_res che di send_payment_status e i due riceventi sono diversi (UT k in un caso, AS nell'altro); il ricevente di send_payment_status \u00e8 il mittente di buy_flights e di payment_failure (quest'ultimo termina la coreografia); il ricevente di buy_flights \u00e8 il mittente di buy_flights_res ; il ricevente di buy_flights_res \u00e8 il mittente di calc_dist e di send_tickets (quest'ultimo termina la coreografia); il ricevente di calc_dist \u00e8 il mittente di calc_dist_res (nella sua prima invocazione); il ricevente di calc_dist_res \u00e8 il mittente della seconda invocazione di calc_dist e di send_tickets (quest'ultimo termina la coreografia); il ricevente di calc_dist \u00e8 il mittente di calc_dist_res nella prima parte della sequenza ( calc_dist ; calc_dist_res )* ; il ricevente di calc_dist_res \u00e8 il mittente di calc_dist nella seconda parte della sopracitata sequenza, che quindi \u00e8 connessa; il ricevente di calc_dist_res (l'ultimo della sequenza lunga almeno uno per ipotesi) \u00e8 il mittente di pren_trs ; il ricevente di pren_trs \u00e8 il mittente di pren_trs_res ; il ricevente di pren_trs_res \u00e8 il mittente di send_tickets (quest'ultimo termina la coreografia).","title":"Acquisto offerta da un utente"},{"location":"coreografie/#proiezioni","text":"Seguono le proiezioni delle coreografie, divise per ruolo.","title":"Proiezioni"},{"location":"coreografie/#as-acmesky","text":"proj( RegistrazioneInteresseUtente , AS) = ( reg @UT k ; reg_res @UT k ) proj( VerificaGiornaliera , AS) = ( ( control @CA 1 ; control_res @CA 1 ) | ... | ( control @CA N ; control_res @CA N ) ) ; ( ( ( notify @PG ; 1 ) + 1 ) | ... | ( ( notify @PG ; 1 ) + 1 ) ) proj( NotificaVoliLastMinute , AS) = ( last_minute @CA i ) ; ( ( ( notify @PG ; 1 ) + 1 ) | ... | ( ( notify @PG ; 1 ) + 1 ) ) proj( AcquistoOfferta , AS) = ( ins_code @UT k ; ins_code_res @UT k ) ; ( ( req_pay @PP ; req_pay_res @PP ; send_payment_ref @UT k ; 1 ; ( 1 | send_payment_status @PP ) ; ( ( buy_flights @CA i ; buy_flights_res @CA i ) ; ( ( ( calc_dist @DG ; calc_dist_res @DG ) ; ( ( calc_dist @DG ; calc_dist_res @DG ) * ( pren_trs @CT j ; pren_trs_res @CT j ) ) + 1 ) + 1 ); send_tickets @UT k ) + payment_failure @UT k ) + ins_code_failure @UT k","title":"AS (ACMESky)"},{"location":"coreografie/#utk-utente","text":"proj( RegistrazioneInteresseUtente , UT k ) = ( reg @AS ; reg_res @AS ) proj( VerificaGiornaliera , UT k ) = ( ( 1 ; 1 ) | ... | ( 1 ; 1 ) ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; message @PG ) + 1) | ... | ( ( 1 ; 1 ) + 1 ) ) = message @PG proj( NotificaVoliLastMinute , UT k ) = ( 1 ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; message @PG ) + 1) | ... | ( ( 1 ; 1 ) + 1 ) ) = message @PG proj( AcquistoOfferta , UT k ) = ( ins_code @AS ; ins_code_res @AS ) ; ( ( 1 ; 1 ; send_payment_ref @AS ; pay_offer @PP ; ( pay_offer_res @PP | 1 ) ) ; ( ( 1 ; 1 ) ; ( ( ( 1 ; 1 ) ( ( 1 ; 1 ) * ( 1 ; 1 ) ) + 1 ) + 1 ) ; send_tickets @AS ) + payment_failure @AS ) + ins_code_failure @AS = ( ins_code @AS ; ins_code_res @AS ) ; ( send_payment_ref @AS ; pay_offer @PP ; pay_offer_res @PP ) ;","title":"UTk (UTente)"},{"location":"coreografie/#dg-distanze-geografiche","text":"proj( RegistrazioneInteresseUtente , DG) = ( 1 ; 1 ) = 1 proj( VerificaGiornaliera , DG) = ( (1 ; 1) | ... | ( 1 ; 1 ) ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; 1 ) + 1 ) ) = 1 proj( NotificaVoliLastMinute , DG) = ( 1 ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; 1 ) + 1 ) ) = 1 proj( AcquistoOfferta , DG) = ( 1 ; 1 ) ; ( ( 1 ; 1 ; 1 ; 1 ; ( 1 | 1 ) ) ; ( ( 1 ; 1 ) ; ( ( ( calc_dist @AS ; calc_dist_res @AS ) ; ( ( calc_dist @AS ; calc_dist_res @AS ) * ( 1 ; 1 ) ) + 1 ) + 1 ); + 1 ) + 1 ) + 1 = ( calc_dist @AS ; calc_dist_res @AS ) ; ( calc_dist @AS ; calc_dist_res @AS ) * ) + 1","title":"DG (Distanze Geografiche)"},{"location":"coreografie/#pp-provider-dei-pagamenti","text":"proj( RegistrazioneInteresseUtente , PP) = ( 1 ; 1 ) = 1 proj( VerificaGiornaliera , PP) = ( ( 1 ; 1 ) | ... | ( 1 ; 1 ) ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; 1 ) + 1 ) ) = 1 proj( NotificaVoliLastMinute , PP) = ( 1 ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; 1 ) + 1 ) ) = 1 proj( AcquistoOfferta , PP) = ( 1 ; 1 ) ; ( ( req_pay @AS ; req_pay_res @AS ; 1 ; pay_offer @UT k ; ( pay_offer_res @UT k | send_payment_status @AS ) ) ; ( ( 1 ; 1 ) ; ( ( ( 1 ; 1 ) ; ( ( 1 ; 1 ) * ( 1 ; 1 ) ) + 1 ) + 1 ); + 1 ) + 1 ) + 1 = ( req_pay @AS ; req_pay_res @AS ; pay_offer @UT k ; ( pay_offer_res @UT k | send_payment_status @AS ) )","title":"PP (Provider dei Pagamenti)"},{"location":"coreografie/#pg-prontogram","text":"proj( RegistrazioneInteresseUtente , PG) = ( 1 ; 1 ) = 1 proj( VerificaGiornaliera , PG) = ( ( 1 ; 1 ) | ... | ( 1 ; 1 ) ) ; ( ( ( notify @AS ; message @UT 1 ) + 1 ) | ... | ( ( notify @AS ; message @UT N ) + 1 ) ) = ( ( notify @AS ; message @UT 1 ) + 1 ) | ... | ( notify @AS ; message @UT k ) | ... | ( ( notify @AS ; message @UT N ) + 1 ) proj( NotificaVoliLastMinute , PG) = ( 1 ) ; ( ( ( notify @AS ; message @UT 1 ) + 1 ) | ... | ( ( notify @AS ; message @UT N ) + 1 ) ) = ( ( notify @AS ; message @UT 1 ) + 1 ) | ... | ( notify @AS ; message @UT k ) | ... | ( ( notify @AS ; message @UT N ) + 1 ) proj( AcquistoOfferta , PG) = ( 1 ; 1 ) ; ( ( 1 ; 1 ; 1 ; 1 ; ( 1 | 1 ) ) ; ( ( 1 ; 1 ) ; ( ( ( 1 ; 1 ) ; ( ( 1 ; 1 ) * ( 1 ; 1 ) ) + 1 ) + 1 ); + 1 ) + 1 ) + 1 = 1","title":"PG (ProntoGram)"},{"location":"coreografie/#ctj-compagnia-trasporti","text":"proj( RegistrazioneInteresseUtente , CT j ) = ( 1 ; 1 ) = 1 proj( VerificaGiornaliera , CT j ) = ( ( 1 ; 1 ) | ... | ( 1 ; 1 ) ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; 1 ) + 1 ) ) = 1 proj( NotificaVoliLastMinute , CT j ) = ( 1 ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; 1 ) + 1 ) ) = 1 proj( AcquistoOfferta , CT j ) = ( 1 ; 1 ) ; ( ( 1 ; 1 ; 1 ; 1 ; ( 1 | 1 ) ; ( ( 1 ; 1 ) ; ( ( ( 1 ; 1 ) ; ( ( 1 ; 1 ) * ( pren_trs @AS; pren_trs_res @AS ) ) + 1 ) + 1 ); + 1 ) + 1 ) + 1 = ( pren_trs @AS; pren_trs_res @AS )","title":"CTj (Compagnia Trasporti)"},{"location":"coreografie/#cai-compagnia-aerea","text":"proj( RegistrazioneInteresseUtente , CA i ) = ( 1 ; 1 ) = 1 proj( VerificaGiornaliera , CA i ) = ( (1 ; 1) | ... | ( control @AS ; control_res @AS ) | ... | ( 1 ; 1 ) ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; 1 ) + 1 ) ) = ( control @AS ; control_res @AS ) proj( NotificaVoliLastMinute , CA i ) = ( last_minute @AS ) ; ( ( ( 1 ; 1 ) + 1 ) | ... | ( ( 1 ; 1 ) + 1 ) ) = last_minute @AS proj( AcquistoOfferta , CA i ) = ( 1 ; 1 ) ; ( ( 1 ; 1 ; 1 ; 1 ; ( 1 | 1 )) ; ( ( buy_flights @AS ; buy_flights_res @CA ) ; ( ( ( 1 ; 1 ) ; ( ( 1 ; 1 ) * ( 1 ; 1 ) ) + 1 ) + 1 ); + 1 ) + 1 ) + 1 = ( buy_flights @AS ; buy_flights_res @CA )","title":"CAi (Compagnia Aerea)"},{"location":"coreografiebpmn/","text":"Registrazione interesse di un utente Processo di registrazione di un interesse da parte di un utente Il diagramma descrive l'interazione fra un utente e ACMESky per l'inserimento nel sistema di un nuovo interesse per un offerta di voli A/R. Oltre ai dati sull'interesse inserisce anche il suo nome utente di ProntoGram . Sia in caso l'interesse venga aggiunto correttamente che in caso contrario ACMESky risponde con l'esito dell'operazione. Verifica giornaliera delle offerte Processo di verifica giornaliera delle offerte delle compagnie aeree Il diagramma descrive le interazioni che avvengono fra ACMESky , le compagnie aeree , ProntoGram e gli utenti, nel contesto della verifica giornaliera della presenza di nuove offerte da comunicare all'utente. Ogni 24 ore, ACMESky contatta le differenti compagnie aeree richiedendo la lista delle nuove offerte inserite. Una volta ricevute, ACMESky verifica se ci sono utenti da notificare in quanto le offerte ricevute soddisfano i loro interessi: in caso affermativo, ACMESky contatta ProntoGram inviando il messaggio da far pervenire all'utente (con il codice offerta per il successivo acquisto); in caso negativo, non vi sono altre interazioni. ProntoGram , alla ricezione della richiesta di inoltro di un messaggio agli utenti, la soddisfa. Ricezione offerte last minute Processo di ricezione delle offerte last minute Il diagramma descrive le interazioni che avvengono fra una compagnia aerea , ACMESky , ProntoGram e gli utenti, nel contesto dell'invio di offerte last minute da parte di una compagnia aerea . Quando una compagnia aerea dispone di offerte last minute, contatta ACMESky inviandole. Una volta ricevute tali offerte, ACMESky verifica se ci sono utenti da notificare in quanto le offerte ricevute soddisfano i loro interessi: in caso affermativo, ACMESky contatta ProntoGram inviando il messaggio da far pervenire all'utente (con il codice offerta per il successivo acquisto); in caso negativo, non vi sono altre interazioni. ProntoGram , alla ricezione della richiesta di inoltro di un messaggio agli utenti, la soddisfa. Acquisto offerta da un utente Processo di acquisto di un'offerta Il diagramma descrive le interazioni tra i diversi partecipanti che portano al pagamento dell'offerta, il cui codice \u00e8 stato inviato precedentemente all'utente, e il successivo invio dei biglietti relativi. Quando un utente invia ad ACMESky il codice dell'offerta, il proprio nome e cognome e il proprio indirizzo, viene avviato il processo di acquisto. Come prima cosa, ACMESky verifica la validit\u00e0 del codice offerta ricevuto: infatti, se questo risultasse errato, gi\u00e0 utilizzato oppure scaduto, l'utente verrebbe avvisato dell'impossibilit\u00e0 di proseguire; nel caso fosse valido, verrebbe dapprima informato e successivamente inoltrata la richiesta di pagamento al Provider dei Pagamenti . Il Provider di Pagamenti risponde alla richiesta di pagamento con un riferimento, al quale l'utente deve accedere, per poter pagare. ACMESky , ricevuto tale riferimento, lo inoltra all'utente il quale ha un tempo massimo di 10 minuti per portare a termine l'operazione di pagamento. Qualsiasi sia l'esito dell'operazione, il Provider dei Pagamenti lo comunica ad ACMESky . Nel caso in cui l'utente non completi entro il tempo previsto il pagamento oppure l'esito risulti negativo, viene notificato il problema e il processo termina. Con il pagamento effettuato correttamente, il processo pu\u00f2 proseguire. ACMESky contatta la compagnia aerea, i cui voli fan parte dell'offerta inviata all'utente, per poterli acquistare. Nel caso in cui il prezzo dell'offerta superi i 1000 \u20ac e l'utente abbia dichiarato un indirizzo entro i 30 Km dall'aeroporto di partenza (distanza calcolata tramite interazione con Distanze Geografiche ), allora ACMESky identifica la compagnia di trasporto pi\u00f9 vicina a tale indirizzo (contattando nuovamente Distanze Geografiche) e prenotando da questa il trasporto da/verso l'aeroporto. In ogni caso, ACMESky invia all'utente i biglietti dei voli e, se \u00e8 stata prenotata una compagnia di trasporto , anche i biglietti per quest'ultima.","title":"Coreografie BPMN"},{"location":"coreografiebpmn/#registrazione-interesse-di-un-utente","text":"Processo di registrazione di un interesse da parte di un utente Il diagramma descrive l'interazione fra un utente e ACMESky per l'inserimento nel sistema di un nuovo interesse per un offerta di voli A/R. Oltre ai dati sull'interesse inserisce anche il suo nome utente di ProntoGram . Sia in caso l'interesse venga aggiunto correttamente che in caso contrario ACMESky risponde con l'esito dell'operazione.","title":"Registrazione interesse di un utente"},{"location":"coreografiebpmn/#verifica-giornaliera-delle-offerte","text":"Processo di verifica giornaliera delle offerte delle compagnie aeree Il diagramma descrive le interazioni che avvengono fra ACMESky , le compagnie aeree , ProntoGram e gli utenti, nel contesto della verifica giornaliera della presenza di nuove offerte da comunicare all'utente. Ogni 24 ore, ACMESky contatta le differenti compagnie aeree richiedendo la lista delle nuove offerte inserite. Una volta ricevute, ACMESky verifica se ci sono utenti da notificare in quanto le offerte ricevute soddisfano i loro interessi: in caso affermativo, ACMESky contatta ProntoGram inviando il messaggio da far pervenire all'utente (con il codice offerta per il successivo acquisto); in caso negativo, non vi sono altre interazioni. ProntoGram , alla ricezione della richiesta di inoltro di un messaggio agli utenti, la soddisfa.","title":"Verifica giornaliera delle offerte"},{"location":"coreografiebpmn/#ricezione-offerte-last-minute","text":"Processo di ricezione delle offerte last minute Il diagramma descrive le interazioni che avvengono fra una compagnia aerea , ACMESky , ProntoGram e gli utenti, nel contesto dell'invio di offerte last minute da parte di una compagnia aerea . Quando una compagnia aerea dispone di offerte last minute, contatta ACMESky inviandole. Una volta ricevute tali offerte, ACMESky verifica se ci sono utenti da notificare in quanto le offerte ricevute soddisfano i loro interessi: in caso affermativo, ACMESky contatta ProntoGram inviando il messaggio da far pervenire all'utente (con il codice offerta per il successivo acquisto); in caso negativo, non vi sono altre interazioni. ProntoGram , alla ricezione della richiesta di inoltro di un messaggio agli utenti, la soddisfa.","title":"Ricezione offerte last minute"},{"location":"coreografiebpmn/#acquisto-offerta-da-un-utente","text":"Processo di acquisto di un'offerta Il diagramma descrive le interazioni tra i diversi partecipanti che portano al pagamento dell'offerta, il cui codice \u00e8 stato inviato precedentemente all'utente, e il successivo invio dei biglietti relativi. Quando un utente invia ad ACMESky il codice dell'offerta, il proprio nome e cognome e il proprio indirizzo, viene avviato il processo di acquisto. Come prima cosa, ACMESky verifica la validit\u00e0 del codice offerta ricevuto: infatti, se questo risultasse errato, gi\u00e0 utilizzato oppure scaduto, l'utente verrebbe avvisato dell'impossibilit\u00e0 di proseguire; nel caso fosse valido, verrebbe dapprima informato e successivamente inoltrata la richiesta di pagamento al Provider dei Pagamenti . Il Provider di Pagamenti risponde alla richiesta di pagamento con un riferimento, al quale l'utente deve accedere, per poter pagare. ACMESky , ricevuto tale riferimento, lo inoltra all'utente il quale ha un tempo massimo di 10 minuti per portare a termine l'operazione di pagamento. Qualsiasi sia l'esito dell'operazione, il Provider dei Pagamenti lo comunica ad ACMESky . Nel caso in cui l'utente non completi entro il tempo previsto il pagamento oppure l'esito risulti negativo, viene notificato il problema e il processo termina. Con il pagamento effettuato correttamente, il processo pu\u00f2 proseguire. ACMESky contatta la compagnia aerea, i cui voli fan parte dell'offerta inviata all'utente, per poterli acquistare. Nel caso in cui il prezzo dell'offerta superi i 1000 \u20ac e l'utente abbia dichiarato un indirizzo entro i 30 Km dall'aeroporto di partenza (distanza calcolata tramite interazione con Distanze Geografiche ), allora ACMESky identifica la compagnia di trasporto pi\u00f9 vicina a tale indirizzo (contattando nuovamente Distanze Geografiche) e prenotando da questa il trasporto da/verso l'aeroporto. In ogni caso, ACMESky invia all'utente i biglietti dei voli e, se \u00e8 stata prenotata una compagnia di trasporto , anche i biglietti per quest'ultima.","title":"Acquisto offerta da un utente"},{"location":"executeinstruction/","text":"Il progetto \u00e8 stato testato su due macchine: macOS Big Sur 11.2.3, Intel Core i9-9880H 2.30 GHz CPU, 16 GB RAM; Windows 10 20H2 build 19042.928, Intel Core i5-3550 3.30 GHz CPU, 16 GB RAM. Entrambi con Docker versione 20.10.5, build 55c4c88 e docker-compose versione 1.29.0, build 07737305. 1. Clonare il repository Il progetto \u00e8 diviso in due macro-repository: codice sorgente: project-sources ; report progetto: project-documentation . Il repository project-sources contiene il codice sorgente dei diversi servizi (submodules del repository) e alcuni file di configurazione per il lancio dei servizi tramite docker-compose . Per clonare il repository e i suoi submodule \u00e8 sufficiente utilizzare il comando: git clone --recurse-submodules git@github.com:sosengers/project-sources.git 2. Creare i file di environment necessari Per poter funzionare correttamente, alcuni servizi hanno bisogno che alcune variabili d'ambiente siano impostate prima della loro esecuzione. Per far questo \u00e8 necessario creare dei file di environment in specifiche cartelle. Questi file contengono password, API KEY e URL che cambiano da macchina a macchina. Di seguito vengono presentati i contenuti dei file environment sufficienti per far funzionare il sistema nel suo intero: flight-company/.env POSTGRES_USER = \"flight_company_admin\" POSTGRES_PASSWORD = \"password\" geographical-distances/.env OPEN_CAGE_API_KEY = \"OpenCage API key\" Al posto di OpenCage API key bisogna mettere una chiave di OpenCage valida, generabile creando un profilo tramite il sito OpenCage e accedendo alla propria area utente. acmesky-middleware/.env FLASK_SECRET = \"flasksecret\" RABBITMQ_HOST = \"acmesky_mq\" MIDDLEWARE_HOST = \"0.0.0.0\" MIDDLEWARE_PORT = \"8080\" ProntoGram-Frontend/.env FLASK_SECRET = \"flasksecret\" RABBITMQ_HOST = \"prontogram_mq\" PRONTOGRAM_HOST = \"0.0.0.0\" PRONTOGRAM_PORT = \"8080\" camunda-workers/.env POSTGRES_USER = \"acmesky_admin\" POSTGRES_PASSWORD = \"password\" MONGO_USER = \"root\" MONGO_PASSWORD = \"password\" ProntoGram-Frontend/prontogram/static/js/environment.js const prontogramSocket = 'http://0.0.0.0:8000' ; PaymentProvider-Backend/.env PAYMENT_PROVIDER_FRONTEND = \"http://127.0.0.1:4002\" PaymentProvider-Frontend/src/environments/environment.ts export const environment = { paymentProviderBackend : \"http://127.0.0.1:4001\" , production : true }; ACMESky-Frontend/src/environments/environment.ts export const environment = { acmeskyBackend : \"http://127.0.0.1:9000\" , acmeskyMiddleware : \"http://127.0.0.1:9001\" , production : true }; 3. Eseguire i servizi Il file docker-compose.yaml contiene le indicazioni per docker-compose su come debbano essere avviati i diversi servizi. Per eseguire tutti i servizi \u00e8 sufficiente lanciare il comando: docker-compose up \u00c8 possibile aggiungere gli argomenti: --build per forzare la compilazione (nel caso non sia la prima volta in cui si utilizza il comando docker-compose con questo file; -d per lanciare i container in modalit\u00e0 detached , liberando il terminale una volta lanciati tutti quanti. Per spegnere tutti i servizi: se si \u00e8 usato solo il comando docker-compose up , \u00e8 sufficiente premere CTRL + C ; se si \u00e8 avviato in modalit\u00e0 detached \u00e8 possibile invocare il comando: docker-compose down Nel caso invece si vogliano eseguire i servizi solamente di alcuni ruoli, \u00e8 stato creato un Makefile che ne semplifica la selezione: ACMESky make acmesky Payment Provider make payment_provider Travel Companies make travel_companies Flight Companies make flight_companies Geographical Distances make geographical_distances ProntoGram make prontogram Di default i log di alcuni servizi sono disabilitati per avere un output pi\u00f9 chiaro e pulito. Per riabilitarli \u00e8 sufficiente commentare ( # ) le righe nel file docker-compose.yaml in cui il driver per il log viene definite come none : logging : driver : none 4. Caricamento dei dati di esempio Per poter testare il sistema \u00e8 necessario caricare dei dati di esempio dei voli delle compagnie aeree. Il container del database delle compagnie aeree ( flight_companies_db ) ha gi\u00e0 dei dataset precaricati, \u00e8 sufficiente importarli all'interno delle tabelle dei database. Questo \u00e8 possibile farlo mediante i seguenti tre (perch\u00e9 tre sono le compagnie aeree di esempio) comandi: per Flight Company 1 docker exec -it flight_companies_db psql -U flight_company_admin -d flightcompany1 -c \"COPY flights(flight_id, departure_airport_code, arrival_airport_code, cost, departure_datetime, arrival_datetime) FROM '/example_data/Flight company 1-FC 1.csv' DELIMITER ';' CSV HEADER;\" per Flight Company 2 docker exec -it flight_companies_db psql -U flight_company_admin -d flightcompany2 -c \"COPY flights(flight_id, departure_airport_code, arrival_airport_code, cost, departure_datetime, arrival_datetime) FROM '/example_data/Flight company 2-FC 2.csv' DELIMITER ';' CSV HEADER;\" per Flight Company 3 docker exec -it flight_companies_db psql -U flight_company_admin -d flightcompany3 -c \"COPY flights(flight_id, departure_airport_code, arrival_airport_code, cost, departure_datetime, arrival_datetime) FROM '/example_data/Flight company 3-FC 3.csv' DELIMITER ';' CSV HEADER;\" Nota sui comandi precedenti Se si \u00e8 modificato la variabile d'ambiente POSTGRES_USER definita nel file flight-company/.env allora \u00e8 necessario modificare il nome utente passato dopo il parametro -U nei tre comandi precedenti. 5. Accesso ai servizi Se i punti precedenti sono stati seguiti correttamente e tutti i servizi sono attivi, \u00e8 possibile accedere: ad ACMESky all'indirizzo http://127.0.0.1:5002 ; a ProntoGram all'indirizzo http://127.0.0.1:8000 ; alla dashboard di Camunda (accedendo con username demo e password demo ) http://127.0.0.1:10000/camunda/ .","title":"Istruzioni per l'esecuzione"},{"location":"executeinstruction/#1-clonare-il-repository","text":"Il progetto \u00e8 diviso in due macro-repository: codice sorgente: project-sources ; report progetto: project-documentation . Il repository project-sources contiene il codice sorgente dei diversi servizi (submodules del repository) e alcuni file di configurazione per il lancio dei servizi tramite docker-compose . Per clonare il repository e i suoi submodule \u00e8 sufficiente utilizzare il comando: git clone --recurse-submodules git@github.com:sosengers/project-sources.git","title":"1. Clonare il repository"},{"location":"executeinstruction/#2-creare-i-file-di-environment-necessari","text":"Per poter funzionare correttamente, alcuni servizi hanno bisogno che alcune variabili d'ambiente siano impostate prima della loro esecuzione. Per far questo \u00e8 necessario creare dei file di environment in specifiche cartelle. Questi file contengono password, API KEY e URL che cambiano da macchina a macchina. Di seguito vengono presentati i contenuti dei file environment sufficienti per far funzionare il sistema nel suo intero: flight-company/.env POSTGRES_USER = \"flight_company_admin\" POSTGRES_PASSWORD = \"password\" geographical-distances/.env OPEN_CAGE_API_KEY = \"OpenCage API key\" Al posto di OpenCage API key bisogna mettere una chiave di OpenCage valida, generabile creando un profilo tramite il sito OpenCage e accedendo alla propria area utente. acmesky-middleware/.env FLASK_SECRET = \"flasksecret\" RABBITMQ_HOST = \"acmesky_mq\" MIDDLEWARE_HOST = \"0.0.0.0\" MIDDLEWARE_PORT = \"8080\" ProntoGram-Frontend/.env FLASK_SECRET = \"flasksecret\" RABBITMQ_HOST = \"prontogram_mq\" PRONTOGRAM_HOST = \"0.0.0.0\" PRONTOGRAM_PORT = \"8080\" camunda-workers/.env POSTGRES_USER = \"acmesky_admin\" POSTGRES_PASSWORD = \"password\" MONGO_USER = \"root\" MONGO_PASSWORD = \"password\" ProntoGram-Frontend/prontogram/static/js/environment.js const prontogramSocket = 'http://0.0.0.0:8000' ; PaymentProvider-Backend/.env PAYMENT_PROVIDER_FRONTEND = \"http://127.0.0.1:4002\" PaymentProvider-Frontend/src/environments/environment.ts export const environment = { paymentProviderBackend : \"http://127.0.0.1:4001\" , production : true }; ACMESky-Frontend/src/environments/environment.ts export const environment = { acmeskyBackend : \"http://127.0.0.1:9000\" , acmeskyMiddleware : \"http://127.0.0.1:9001\" , production : true };","title":"2. Creare i file di environment necessari"},{"location":"executeinstruction/#3-eseguire-i-servizi","text":"Il file docker-compose.yaml contiene le indicazioni per docker-compose su come debbano essere avviati i diversi servizi. Per eseguire tutti i servizi \u00e8 sufficiente lanciare il comando: docker-compose up \u00c8 possibile aggiungere gli argomenti: --build per forzare la compilazione (nel caso non sia la prima volta in cui si utilizza il comando docker-compose con questo file; -d per lanciare i container in modalit\u00e0 detached , liberando il terminale una volta lanciati tutti quanti. Per spegnere tutti i servizi: se si \u00e8 usato solo il comando docker-compose up , \u00e8 sufficiente premere CTRL + C ; se si \u00e8 avviato in modalit\u00e0 detached \u00e8 possibile invocare il comando: docker-compose down Nel caso invece si vogliano eseguire i servizi solamente di alcuni ruoli, \u00e8 stato creato un Makefile che ne semplifica la selezione: ACMESky make acmesky Payment Provider make payment_provider Travel Companies make travel_companies Flight Companies make flight_companies Geographical Distances make geographical_distances ProntoGram make prontogram Di default i log di alcuni servizi sono disabilitati per avere un output pi\u00f9 chiaro e pulito. Per riabilitarli \u00e8 sufficiente commentare ( # ) le righe nel file docker-compose.yaml in cui il driver per il log viene definite come none : logging : driver : none","title":"3. Eseguire i servizi"},{"location":"executeinstruction/#4-caricamento-dei-dati-di-esempio","text":"Per poter testare il sistema \u00e8 necessario caricare dei dati di esempio dei voli delle compagnie aeree. Il container del database delle compagnie aeree ( flight_companies_db ) ha gi\u00e0 dei dataset precaricati, \u00e8 sufficiente importarli all'interno delle tabelle dei database. Questo \u00e8 possibile farlo mediante i seguenti tre (perch\u00e9 tre sono le compagnie aeree di esempio) comandi: per Flight Company 1 docker exec -it flight_companies_db psql -U flight_company_admin -d flightcompany1 -c \"COPY flights(flight_id, departure_airport_code, arrival_airport_code, cost, departure_datetime, arrival_datetime) FROM '/example_data/Flight company 1-FC 1.csv' DELIMITER ';' CSV HEADER;\" per Flight Company 2 docker exec -it flight_companies_db psql -U flight_company_admin -d flightcompany2 -c \"COPY flights(flight_id, departure_airport_code, arrival_airport_code, cost, departure_datetime, arrival_datetime) FROM '/example_data/Flight company 2-FC 2.csv' DELIMITER ';' CSV HEADER;\" per Flight Company 3 docker exec -it flight_companies_db psql -U flight_company_admin -d flightcompany3 -c \"COPY flights(flight_id, departure_airport_code, arrival_airport_code, cost, departure_datetime, arrival_datetime) FROM '/example_data/Flight company 3-FC 3.csv' DELIMITER ';' CSV HEADER;\" Nota sui comandi precedenti Se si \u00e8 modificato la variabile d'ambiente POSTGRES_USER definita nel file flight-company/.env allora \u00e8 necessario modificare il nome utente passato dopo il parametro -U nei tre comandi precedenti.","title":"4. Caricamento dei dati di esempio"},{"location":"executeinstruction/#5-accesso-ai-servizi","text":"Se i punti precedenti sono stati seguiti correttamente e tutti i servizi sono attivi, \u00e8 possibile accedere: ad ACMESky all'indirizzo http://127.0.0.1:5002 ; a ProntoGram all'indirizzo http://127.0.0.1:8000 ; alla dashboard di Camunda (accedendo con username demo e password demo ) http://127.0.0.1:10000/camunda/ .","title":"5. Accesso ai servizi"},{"location":"implementazione/","text":"Implementazione In questa sezione vengono presentate le scelte implementative effettuate per la realizzazione dei servizi presenti in questo sistema. Diagramma architetturale Diagramma architetturale Il diagramma descrive come i diversi servizi comunicano tra loro e quali tecnologie abbiamo adottato per implementarli. ACMESky : questo ruolo \u00e8 formato da molteplici componenti: Camunda BPMN Engine nel quale sono stati caricati i diagrammi BPMN descritti nella sezione precedente . Si occupa di gestire i Business Process, viene contattato dai camunda workers per eseguire i diversi task. Camunda Workers : insieme di funzioni scritte in Python con l'ausilio della libreria camunda-external-task-client-python3 che eseguono i task dichiarati nei diagrammi BPMN; in base al task da eseguire il worker pu\u00f2 comunicare con il database relazionale PostgreSQL, il database NoSQL MongoDB o il message broker RabbitMQ, ma anche con servizi esterni ad ACMESky come il PaymentProvider, ProntoGram, le compagnie aeree e di trasporto e il servizio per il calcolo delle distanze geografiche. Esiste un worker per ogni task presente nei diagrammi BPMN; questa soluzione \u00e8 stata adottata per avere maggior chiarezza e semplicit\u00e0 nella gestione dei diversi task. PostgreSQL : database relazionale utilizzato per memorizzare i voli delle compagnie aeree, quali voli combacianti con le richieste degli utenti e le transazioni dei pagamenti. MongoDB : database non relazionale utilizzato per memorizzare gli interessi degli utenti. Redis : utilizzato come cache per memorizzare dei dati utili al corretto scambio dei dati tra backend e frontend. ACMESky backend : servizio sviluppato in Python con l'ausilio della libreria connexion / flask . Lo scheletro di base \u00e8 stato generato a partire dalle specifiche OpenAPI tramite lo strumento OpenAPI Generator . Il suo scopo \u00e8 quello di mettere in contatto ACMESky con il resto del mondo: in particolare riceve le offerte last minute dalle compagnie aeree, le ricevute di pagamento dal Payment Provider e gestisce le richieste dal frontend di ACMESky. Ogni richiesta viene convertita in un messaggio che viene mandato a Camunda utilizzando le sue API . ACMESky frontend : servizio sviluppato in Angular che viene utilizzato dagli utenti per interagire con ACMESky e permette, tramite un'interfaccia web, di registrare il proprio interesse per un viaggio e acquistare i biglietti per i voli compresi in un offerta dopo aver ricevuto il codice offerta tramite il proprio account ProntoGram. ACMESky middleware : servizio sviluppato in Python con l'ausilio della libreria flask e del suo plugin flask-SocketIO con lo scopo di mettere in contatto il message broker e il frontend utilizzando i WebSocket. Message broker : istanza di RabbitMQ utilizzata per salvare i messaggi di un worker che devono essere mostrati dal frontend, in questa maniera i worker sono indipendenti dal frontend. Flight companies : questi ruoli sono stati realizzati utilizzando Jolie , un linguaggio orientato ai servizi. Lo scheletro dei programmi \u00e8 stato ottenuto partendo dalle specifiche OpenAPI e tramite il tool openapi2jolie. Vengono contattate da un worker di ACMESky ogni giorno per ottenere la lista di nuovi voli e, in caso venga aggiunta una nuova offerta, contattano ACMESky backend per notificarglielo. Travel companies : questi ruoli sono stati realizzati utilizzando Jolie , un linguaggio orientato ai servizi. Tramite il protocollo SOAP vengono contattate da un worker di ACMESky per prenotare il trasferimento dalla casa dell'utente all'aeroporto. Il file WSDL \u00e8 stato generato tramite il tool jolie2wsdl e reso accessibile dalla rete cosicch\u00e9 il worker di ACMESky potesse utilizzare la libreria Zeep che si occupa di scaricare e interpretare il file WSDL e di creare il client corretto per eseguire le diverse operazioni descritte nel file. Geographical distances : servizio per il calcolo delle distanze geografiche, sviluppato in Python con l'ausilio della libreria connexion / flask . Lo scheletro di base \u00e8 stato generato a partire dalle specifiche OpenAPI tramite lo strumento OpenAPI Generator . Viene contattato da un worker di ACMESky e restituisce la distanza tra due indirizzi. Per far questo, ottiene le coordinate dei due indirizzi utilizzando le API messe a disposizione da OpenCage (in particolare quelle per il reverse geocoding) e la formula di Haversine per il calcolo della distanza tra due punti sul globo terrestre. Payment Provider : formato da un backend sviluppato in Python con l'ausilio della libreria connexion / flask , un frontend sviluppato in Angular e un istanza di Redis utilizzata per mantenere in cache alcune informazioni utili per il processo di pagamento. Un worker di ACMESky contatta il backend che crea un nuovo processo di pagamento e restituisce un url al quale l'utente pu\u00f2 pagare. Una volta che il pagamento \u00e8 avvenuto il backend contatta ACMESky che verifica l'esito del pagamento e, in caso positivo, procede con il processo. ProntoGram : composto da un backend sviluppato in Python con l'ausilio della libreria connexion / flask che pubblica su una coda RabbitMQ dalla quale legge il frontend del servizio. Il backend \u00e8 contattato da un worker di ACMESky che manda il codice dell'offerta quando un match tra una richiesta di un utente e un viaggio viene trovato.","title":""},{"location":"implementazione/#implementazione","text":"In questa sezione vengono presentate le scelte implementative effettuate per la realizzazione dei servizi presenti in questo sistema.","title":"Implementazione"},{"location":"implementazione/#diagramma-architetturale","text":"Diagramma architetturale Il diagramma descrive come i diversi servizi comunicano tra loro e quali tecnologie abbiamo adottato per implementarli. ACMESky : questo ruolo \u00e8 formato da molteplici componenti: Camunda BPMN Engine nel quale sono stati caricati i diagrammi BPMN descritti nella sezione precedente . Si occupa di gestire i Business Process, viene contattato dai camunda workers per eseguire i diversi task. Camunda Workers : insieme di funzioni scritte in Python con l'ausilio della libreria camunda-external-task-client-python3 che eseguono i task dichiarati nei diagrammi BPMN; in base al task da eseguire il worker pu\u00f2 comunicare con il database relazionale PostgreSQL, il database NoSQL MongoDB o il message broker RabbitMQ, ma anche con servizi esterni ad ACMESky come il PaymentProvider, ProntoGram, le compagnie aeree e di trasporto e il servizio per il calcolo delle distanze geografiche. Esiste un worker per ogni task presente nei diagrammi BPMN; questa soluzione \u00e8 stata adottata per avere maggior chiarezza e semplicit\u00e0 nella gestione dei diversi task. PostgreSQL : database relazionale utilizzato per memorizzare i voli delle compagnie aeree, quali voli combacianti con le richieste degli utenti e le transazioni dei pagamenti. MongoDB : database non relazionale utilizzato per memorizzare gli interessi degli utenti. Redis : utilizzato come cache per memorizzare dei dati utili al corretto scambio dei dati tra backend e frontend. ACMESky backend : servizio sviluppato in Python con l'ausilio della libreria connexion / flask . Lo scheletro di base \u00e8 stato generato a partire dalle specifiche OpenAPI tramite lo strumento OpenAPI Generator . Il suo scopo \u00e8 quello di mettere in contatto ACMESky con il resto del mondo: in particolare riceve le offerte last minute dalle compagnie aeree, le ricevute di pagamento dal Payment Provider e gestisce le richieste dal frontend di ACMESky. Ogni richiesta viene convertita in un messaggio che viene mandato a Camunda utilizzando le sue API . ACMESky frontend : servizio sviluppato in Angular che viene utilizzato dagli utenti per interagire con ACMESky e permette, tramite un'interfaccia web, di registrare il proprio interesse per un viaggio e acquistare i biglietti per i voli compresi in un offerta dopo aver ricevuto il codice offerta tramite il proprio account ProntoGram. ACMESky middleware : servizio sviluppato in Python con l'ausilio della libreria flask e del suo plugin flask-SocketIO con lo scopo di mettere in contatto il message broker e il frontend utilizzando i WebSocket. Message broker : istanza di RabbitMQ utilizzata per salvare i messaggi di un worker che devono essere mostrati dal frontend, in questa maniera i worker sono indipendenti dal frontend. Flight companies : questi ruoli sono stati realizzati utilizzando Jolie , un linguaggio orientato ai servizi. Lo scheletro dei programmi \u00e8 stato ottenuto partendo dalle specifiche OpenAPI e tramite il tool openapi2jolie. Vengono contattate da un worker di ACMESky ogni giorno per ottenere la lista di nuovi voli e, in caso venga aggiunta una nuova offerta, contattano ACMESky backend per notificarglielo. Travel companies : questi ruoli sono stati realizzati utilizzando Jolie , un linguaggio orientato ai servizi. Tramite il protocollo SOAP vengono contattate da un worker di ACMESky per prenotare il trasferimento dalla casa dell'utente all'aeroporto. Il file WSDL \u00e8 stato generato tramite il tool jolie2wsdl e reso accessibile dalla rete cosicch\u00e9 il worker di ACMESky potesse utilizzare la libreria Zeep che si occupa di scaricare e interpretare il file WSDL e di creare il client corretto per eseguire le diverse operazioni descritte nel file. Geographical distances : servizio per il calcolo delle distanze geografiche, sviluppato in Python con l'ausilio della libreria connexion / flask . Lo scheletro di base \u00e8 stato generato a partire dalle specifiche OpenAPI tramite lo strumento OpenAPI Generator . Viene contattato da un worker di ACMESky e restituisce la distanza tra due indirizzi. Per far questo, ottiene le coordinate dei due indirizzi utilizzando le API messe a disposizione da OpenCage (in particolare quelle per il reverse geocoding) e la formula di Haversine per il calcolo della distanza tra due punti sul globo terrestre. Payment Provider : formato da un backend sviluppato in Python con l'ausilio della libreria connexion / flask , un frontend sviluppato in Angular e un istanza di Redis utilizzata per mantenere in cache alcune informazioni utili per il processo di pagamento. Un worker di ACMESky contatta il backend che crea un nuovo processo di pagamento e restituisce un url al quale l'utente pu\u00f2 pagare. Una volta che il pagamento \u00e8 avvenuto il backend contatta ACMESky che verifica l'esito del pagamento e, in caso positivo, procede con il processo. ProntoGram : composto da un backend sviluppato in Python con l'ausilio della libreria connexion / flask che pubblica su una coda RabbitMQ dalla quale legge il frontend del servizio. Il backend \u00e8 contattato da un worker di ACMESky che manda il codice dell'offerta quando un match tra una richiesta di un utente e un viaggio viene trovato.","title":"Diagramma architetturale"},{"location":"serviziweb/","text":"Servizi web Nella seguente sezione vengono illustrate le interfacce con cui i vari partecipanti coinvolti nel funzionamento di ACMESky permettono di essere contattati e fornire dei servizi ai loro utilizzatori. \u00c8 stato scelto di utilizzare due modalit\u00e0 differenti per rendere disponibili tali servizi, mediante: API RESTful : implementano lo stile architetturale REST, sono state impiegate per fornire i servizi di ACMESky , delle Flight Company , di Geographical Distances e di ProntoGram ; API SOAP : sono state impiegate per fornire i servizi delle Travel Company .","title":""},{"location":"serviziweb/#servizi-web","text":"Nella seguente sezione vengono illustrate le interfacce con cui i vari partecipanti coinvolti nel funzionamento di ACMESky permettono di essere contattati e fornire dei servizi ai loro utilizzatori. \u00c8 stato scelto di utilizzare due modalit\u00e0 differenti per rendere disponibili tali servizi, mediante: API RESTful : implementano lo stile architetturale REST, sono state impiegate per fornire i servizi di ACMESky , delle Flight Company , di Geographical Distances e di ProntoGram ; API SOAP : sono state impiegate per fornire i servizi delle Travel Company .","title":"Servizi web"},{"location":"uml/","text":"In questa sezione viene rappresentata, sotto forma di diagrammi UML con profilo TinySOA , la modellazione della SOA di cui fa parte l'organizzazione ACMESky . I seguenti diagrammi hanno lo scopo di evidenziare, per ogni servizio, quali sono le capability accessibili tramite il sistema e le interfacce che le espongono, esternamente e/o internamente, da ogni organizzazione facente parte della SOA. In particolare, si distinguono tre tipi di servizi: Task (o Process ): espone capability realizzate attraverso processi interni all'organizzazione, eventualmente svolti da umani. Sono strettamente legati al dominio del problema; Entity : corrisponde a una singola attivit\u00e0, solitamente automatica (per esempio, il salvataggio di un record in una base di dati); Utility : come i Task, ma non sono prettamente legati al dominio del problema. Registrazione interesse di un utente Diagramma UML che descrive come vengono implementati i task del processo di registrazione di un interesse di un utente Nel diagramma sovrastante sono evidenziate le capability emerse dall'analisi del diagramma BPMN \"Registrazione interesse utente\" e le interfacce che le espongono. Le capability emerse, per il ruolo di ACMESky sono: Interest e InterestRegistration . Queste due capability sono esposte mediante due interfacce e la capability InterestRegistration dipende dall'interfaccia che espone la capability Interest . Queste due capability permettono al sistema di recepire l'interesse da parte di un utente per un viaggio e salvarlo in maniera da poterlo riutilizzare per successivi controlli. Inoltre, dal diagramma BPMN \u00e8 emersa anche un'altra capability, questa volta relativa all'utente: OperationResult . Questa capability permette all'utente di recepire il successo o il fallimento dell'inserimento del suo interesse all'interno del sistema. L'interfaccia che espone quest'ultima capability \u00e8 una dipendenza della capability InterestRegistration . Verifica giornaliera delle offerte Diagramma UML che descrive come vengono implementati i task del processo di verifica giornaliera delle offerte delle compagnie aree e notifica degli utenti Nel diagramma sovrastante sono evidenziate le capability emerse dall'analisi del diagramma BPMN \"Verifica giornaliere delle offerte\" e le interfacce che le espongono. Le capability emerse, per il ruolo di ACMESky sono: DailyOffersCheck e Offer . Queste due capability sono esposte mediante tre interfacce e la capability DailyOffersCheck dipende dalle interfacce OfferSaving e OfferFinding che espongono la capability Offer . Queste due capability permettono al sistema di memorizzare le offerte delle compagnie aeree e successivamente verificare se esse sono coerenti con gli interessi dichiarati dai suoi utenti. DailyOffersCheck dipende inoltre da un'altra capability, FlightOffersRetrieval di Flight Company (una compagnia aerea), per ricevere le offerte di voli delle compagnie. La capability Offer , invece, dipende dalla capability di invio messaggi di ProntoGram , Message , esposta attraverso un'interfaccia. Infine, per contattare l'utente, la capability Message di ProntoGram dipende da un ulteriore capability MessagePublishing con la quale notificare l'utente della presenza di nuovi messaggi a lui indirizzati. Ricezione offerte last minute Diagramma UML che descrive come vengono implementati i task del processo di ricezione di offerte dalle compagnie aree e notifica degli utenti Nel diagramma sovrastante sono evidenziate le capability emerse dall'analisi del diagramma BPMN \"Acquisto offerta da un utente\" e le interfacce che le espongono. Le capability emerse, per il ruolo di ACMESky sono: LastMinuteOffersPublishing e Offer . Queste due capability sono esposte mediante tre interfacce e la capability LastMinuteOffersPublishing dipende dalle interfacce OfferSaving e OfferFinding che espongono la capability Offer . Queste due capability permettono al sistema di memorizzare le offerte last-minute ricevute direttamente dalle compagnie aeree e successivamente verificare se esse sono coerenti con gli interessi dichiarati dai suoi utenti. Le capability Offer , Message , MessagePublishing e relative interfacce sono le stesse che sono illustrate nella precedente sezione. Acquisto offerta da un utente Diagramma UML che descrive come vengono implementati i task del processo di acquisto di un'offerta Nel diagramma sovrastante sono evidenziate le capability emerse dall'analisi del diagramma BPMN \"Acquisto offerta da un utente\" e le interfacce che le espongono. Le capability emerse per il ruolo di ACMESky sono: OfferCodeInsertion , PaymentHandler , Payment , Offer e Distance ; ognuna di queste capability \u00e8 esposta da una specifica interfaccia. Queste capability permettono al sistema di: ricevere la richiesta di acquisto di un'offerta da parte di un utente, ricevere l'esito di un'operazione di pagamento, verificare l'esito di un pagamento, verificare il codice dell'offerta inserito da un utente e controllare la distanza geografica tra due coordinate. La capability OfferCodeInsertion dipende dalle interfacce che espongono la capability Offer per poter verificare la validit\u00e0 del codice inserito e Distance per controllare la distanza tra la casa dell'utente e l'aeroporto. La capability PaymentHandler dipende dall'interfaccia che espone la capability Payment per verificare l'esito del pagamento. Per il ruolo di PaymentProvider abbiamo individuato la capability PaymentRequest esposta da due interfacce PaymentRequest e PaymentHandler . L'interfaccia PaymentRequest \u00e8 una dipendenza della capability OfferCodeInsertion per poter creare la richiesta di un pagamento da richiedere poi all'utente. Le capability emerse per il ruolo di User sono PaymentRequest e OperationResult , ognuna esposta da un interfaccia specifica. L'interfaccia di PaymentRequest \u00e8 una dipendenza della capability PaymentRequest del ruolo PaymentProvider per permettere al provider di pagamenti di richiedere all'utente i dati per effettuare un pagamento; a sua volta la capability PaymentRequest \u00e8 una dipendenza dell'interfaccia PaymentHandler per poter interagire con il provider di pagamento. Un ulteriore capability associata al ruolo di User \u00e8 OperationResult la quale permette all'utente di ricevere messaggi di successo o di errore da parte di altri ruoli; infatti l'interfaccia che espone tale capability \u00e8 una dipendenza della capability OfferCodeInsertion e PaymentHandler di ACMESky . Il ruolo TravelCompany possiede la capability BookTransfer e l'interfaccia che la espone \u00e8 una dipendenza di OfferCodeInsertion per poter prenotare il servizio di traporto in caso l'utente ne abbia diritto. Il ruolo GeographicDistance possiede la capability DistanceComputation e, come per la precedente, l'interfaccia che la espone \u00e8 una dipendenza di OfferCodeInsertion per poter calcolare la distanza tra due punti geografici. Infine, il ruolo FlightCompany ha la capability BuyFlights la cui interfaccia \u00e8 dipendenza di OfferCodeInsertion per permettere ad ACMESky ti acquistare i voli di interesse per l'utente.","title":"UML"},{"location":"uml/#registrazione-interesse-di-un-utente","text":"Diagramma UML che descrive come vengono implementati i task del processo di registrazione di un interesse di un utente Nel diagramma sovrastante sono evidenziate le capability emerse dall'analisi del diagramma BPMN \"Registrazione interesse utente\" e le interfacce che le espongono. Le capability emerse, per il ruolo di ACMESky sono: Interest e InterestRegistration . Queste due capability sono esposte mediante due interfacce e la capability InterestRegistration dipende dall'interfaccia che espone la capability Interest . Queste due capability permettono al sistema di recepire l'interesse da parte di un utente per un viaggio e salvarlo in maniera da poterlo riutilizzare per successivi controlli. Inoltre, dal diagramma BPMN \u00e8 emersa anche un'altra capability, questa volta relativa all'utente: OperationResult . Questa capability permette all'utente di recepire il successo o il fallimento dell'inserimento del suo interesse all'interno del sistema. L'interfaccia che espone quest'ultima capability \u00e8 una dipendenza della capability InterestRegistration .","title":"Registrazione interesse di un utente"},{"location":"uml/#verifica-giornaliera-delle-offerte","text":"Diagramma UML che descrive come vengono implementati i task del processo di verifica giornaliera delle offerte delle compagnie aree e notifica degli utenti Nel diagramma sovrastante sono evidenziate le capability emerse dall'analisi del diagramma BPMN \"Verifica giornaliere delle offerte\" e le interfacce che le espongono. Le capability emerse, per il ruolo di ACMESky sono: DailyOffersCheck e Offer . Queste due capability sono esposte mediante tre interfacce e la capability DailyOffersCheck dipende dalle interfacce OfferSaving e OfferFinding che espongono la capability Offer . Queste due capability permettono al sistema di memorizzare le offerte delle compagnie aeree e successivamente verificare se esse sono coerenti con gli interessi dichiarati dai suoi utenti. DailyOffersCheck dipende inoltre da un'altra capability, FlightOffersRetrieval di Flight Company (una compagnia aerea), per ricevere le offerte di voli delle compagnie. La capability Offer , invece, dipende dalla capability di invio messaggi di ProntoGram , Message , esposta attraverso un'interfaccia. Infine, per contattare l'utente, la capability Message di ProntoGram dipende da un ulteriore capability MessagePublishing con la quale notificare l'utente della presenza di nuovi messaggi a lui indirizzati.","title":"Verifica giornaliera delle offerte"},{"location":"uml/#ricezione-offerte-last-minute","text":"Diagramma UML che descrive come vengono implementati i task del processo di ricezione di offerte dalle compagnie aree e notifica degli utenti Nel diagramma sovrastante sono evidenziate le capability emerse dall'analisi del diagramma BPMN \"Acquisto offerta da un utente\" e le interfacce che le espongono. Le capability emerse, per il ruolo di ACMESky sono: LastMinuteOffersPublishing e Offer . Queste due capability sono esposte mediante tre interfacce e la capability LastMinuteOffersPublishing dipende dalle interfacce OfferSaving e OfferFinding che espongono la capability Offer . Queste due capability permettono al sistema di memorizzare le offerte last-minute ricevute direttamente dalle compagnie aeree e successivamente verificare se esse sono coerenti con gli interessi dichiarati dai suoi utenti. Le capability Offer , Message , MessagePublishing e relative interfacce sono le stesse che sono illustrate nella precedente sezione.","title":"Ricezione offerte last minute"},{"location":"uml/#acquisto-offerta-da-un-utente","text":"Diagramma UML che descrive come vengono implementati i task del processo di acquisto di un'offerta Nel diagramma sovrastante sono evidenziate le capability emerse dall'analisi del diagramma BPMN \"Acquisto offerta da un utente\" e le interfacce che le espongono. Le capability emerse per il ruolo di ACMESky sono: OfferCodeInsertion , PaymentHandler , Payment , Offer e Distance ; ognuna di queste capability \u00e8 esposta da una specifica interfaccia. Queste capability permettono al sistema di: ricevere la richiesta di acquisto di un'offerta da parte di un utente, ricevere l'esito di un'operazione di pagamento, verificare l'esito di un pagamento, verificare il codice dell'offerta inserito da un utente e controllare la distanza geografica tra due coordinate. La capability OfferCodeInsertion dipende dalle interfacce che espongono la capability Offer per poter verificare la validit\u00e0 del codice inserito e Distance per controllare la distanza tra la casa dell'utente e l'aeroporto. La capability PaymentHandler dipende dall'interfaccia che espone la capability Payment per verificare l'esito del pagamento. Per il ruolo di PaymentProvider abbiamo individuato la capability PaymentRequest esposta da due interfacce PaymentRequest e PaymentHandler . L'interfaccia PaymentRequest \u00e8 una dipendenza della capability OfferCodeInsertion per poter creare la richiesta di un pagamento da richiedere poi all'utente. Le capability emerse per il ruolo di User sono PaymentRequest e OperationResult , ognuna esposta da un interfaccia specifica. L'interfaccia di PaymentRequest \u00e8 una dipendenza della capability PaymentRequest del ruolo PaymentProvider per permettere al provider di pagamenti di richiedere all'utente i dati per effettuare un pagamento; a sua volta la capability PaymentRequest \u00e8 una dipendenza dell'interfaccia PaymentHandler per poter interagire con il provider di pagamento. Un ulteriore capability associata al ruolo di User \u00e8 OperationResult la quale permette all'utente di ricevere messaggi di successo o di errore da parte di altri ruoli; infatti l'interfaccia che espone tale capability \u00e8 una dipendenza della capability OfferCodeInsertion e PaymentHandler di ACMESky . Il ruolo TravelCompany possiede la capability BookTransfer e l'interfaccia che la espone \u00e8 una dipendenza di OfferCodeInsertion per poter prenotare il servizio di traporto in caso l'utente ne abbia diritto. Il ruolo GeographicDistance possiede la capability DistanceComputation e, come per la precedente, l'interfaccia che la espone \u00e8 una dipendenza di OfferCodeInsertion per poter calcolare la distanza tra due punti geografici. Infine, il ruolo FlightCompany ha la capability BuyFlights la cui interfaccia \u00e8 dipendenza di OfferCodeInsertion per permettere ad ACMESky ti acquistare i voli di interesse per l'utente.","title":"Acquisto offerta da un utente"},{"location":"implementazione/acmesky/","text":"Torna a Implementazione . Panoramica graph TD CW --> DBs CW --> OS[Altri servizi] CW --> C CW --> R BE --> C FE --> BE FE --> MW Utente --> FE MW --> R subgraph ACMESky DBs(Database) CW[Camunda Workers] C[Camunda] BE[Backend] R[RabbitMQ] FE[Frontend] MW[Middleware] end ACMESky \u00e8 l'insieme di servizi che permettono ad un utente di inserire un proprio interesse all'interno del sistema e di acquistare i voli per un viaggio. Interazioni Utente e ACMESky graph LR BE -->|Correlate messages| C FE -->|POST /offers/buy| BE FE -->|POST /interests| BE FE -->|WebSocket| MW Utente --> FE MW -->|Subscribe| R subgraph ACMESky C[Camunda] BE[Backend] R[RabbitMQ] FE[Frontend] MW[Middleware] end L'utente interagisce con l'interfaccia web messa a disposizione dal frontend. Il frontend mette a disposizione due funzionalit\u00e0, l'aggiunta di un nuovo interesse e l'acquisto di un viaggio. Queste due operazioni sono permesse da due chiamate HTTP al backend di ACMESky : POST /interests e POST /offers/buy . Homepage ACMESky Aggiunta di un nuovo interesse Aggiunta di un nuovo interesse Un utente per aggiungere il proprio interesse inserisce i dati richiesti e preme il pulsante \"Conferma\". I dati del modulo vengono inviati al backend che, a sua volta, li invia a Camunda, avviando cos\u00ec una nuova istanza del business process Registrazione interesse utente nell'engine; i cui task verranno svolti dai worker assegnati, tra i quali il worker register-interest , che aggiunge l'interesse all'interno di MongoDB. Verr\u00e0 fatto nuovamente riferimento a questo database quando verranno controllati gli interessi non ancora soddisfatti alla ricerca di offerte che soddisfano i requisiti salvati. Acquisto di un'offerta Inserimento dati acquisto offerta Quando un utente riceve il codice offerta tramite ProntoGram si pu\u00f2 recare su questa pagine e, riempiendo il form con i dati richiesti, avviare il processo di acquisto di un'offerta. Il frontend contatta il backend passandogli i dati inseriti dall'utente e, a sua volta, invia un messaggio a Camunda che avvia una nuova istanza del processo di business Acquisto offerta da un utente . Il backend risponde con il codice che verr\u00e0 usato per la comunicazione tra frontend e middleware tramite WebSocket. Quando un worker deve comunicare con il frontend, pubblica un messaggio sulla coda RabbitMQ utilizzando lo stesso codice comunicato al frontend. Il middleware, essendosi sottoscritto alla stessa coda, utilizza il WebSocket per comunicare il messaggio al giusto utente. In questo modo \u00e8 possibile: comunicare errori: Comunicazione errori al Frontend richiedere il pagamento da parte dell'utente: Richiesta pagamento mostrare l'offerta acquistata: Biglietti acquistati Interazioni ACMESky e servizi esterni Per poter compiere i diversi task, i worker contattano dei servizi che sono esterni ad ACMESky . graph LR CW --> FC[Flight Company] CW --> TC[Travel Company] CW --> GD[Geographical distances] CW --> PP[Payment Provider] CW --> PG[ProntoGram] subgraph ACMESky CW[Camunda Workers] end subgraph Servizi-Esterni FC[Flight Company] TC[Travel Company] GD[Geographical distances] PP[Payment Provider] PG[ProntoGram] end Per interagire con i servizi RESTful esterni \u00e8 stata utilizzata la libreria Requests di Python che permette in maniera molto semplice di soddisfare la necessit\u00e0 di fare chiamate HTTP POST e GET : get_response = requests.get(url) post_response = requests.post(url, json=dict_representing_the_json) Flight Company graph TD CW1 -->|POST /flights/buy| FC[Flight Company] CW2 -->|GET /flights/offers| FC[Flight Company] FC[Flight Company] -->|POST /offers/lastminute|B subgraph ACMESky B[Backend] subgraph Camunda-Workers CW1[Buy flights] CW2[Get flight offers] end end %%style Camunda-Workers fill:#90EE90 ACMESky comunica con le Flight Company tramite chiamate HTTP. Quando devo effettuare l'acquisto di uno o pi\u00f9 voli invia un documento in formato JSON come corpo della richiesta all'endpoint POST /flights/buy mentre, una volta al giorno contatta l'endpoint GET /flights/offers per ottenere la lista di voli aggiunti nelle ultime 24h, ovvero quando Camunda avvia il business process Verifica giornaliera delle offerte Quando un nuovo volo viene aggiunto ad una compagnia aerea, questo viene, a sua volta, inviato anche ad ACMESky tramite l'endpoint POST /offers/lastminute Travel Company graph TD CW1 -->|Retrieve travelcompany.wsdl| TCf CW1 -->|SOAP buyTransfer| TC subgraph ACMESky subgraph Camunda-Workers CW1[Book transfer] end end subgraph Travel-Companies TC[Jolie service] TCf[Travel Company file provider] end %%style Camunda-Workers fill:#90EE90 Quando ACMESky deve prenotare il trasferimento da/verso casa dell'utente e aeroporto utilizza la libreria Zeep che \u00e8 in grado di generare un client SOAP a partire dal file WSDL che descrive il servizio. soap_client = Client(wsdl=wsdl_url) soap_response = soap_client.service.buyTransfers( departure_transfer_datetime=outbound_departure_transfer_datetime.strftime(\"%Y-%m-%dT%H:%M:%S\"), customer_address=str(offer_purchase_data.address), airport_code=offer_match.outbound_flight.departure_airport_code, customer_name=f\"{offer_purchase_data.name} {offer_purchase_data.surname}\", arrival_transfer_datetime=comeback_arrival_transfer_datetime.strftime(\"%Y-%m-%dT%H:%M:%S\") ) Geographical distances graph TD CW1 -->|POST /distance| GD[Geographical Distances] CW2 -->|POST /distance| GD[Geographical Distances] subgraph ACMESky subgraph Camunda-Workers CW1[Check distance house airport] CW2[Get min distance house travel company] end end %%style Camunda-Workers fill:#90EE90 ACMESky utilizza il servizio per il calcolo delle distanze geografiche per calcolare la distanza tra due indirizzi. Il servizio \u00e8 contattato due volte: quando c'\u00e8 da calcolare la distanza tra la casa del cliente e l'aeroporto e per trovare la compagnia di trasporto pi\u00f9 vicina alla casa del cliente. Payment Provider graph TD CW1 -->|POST /payments/request| PP[Payment Provider] CW1 -->|Publish payment URL|R PP[Payment Provider] -->|POST /payments| BE BE -->|Send correlate message| C CW2 -->|Polling for new task| C subgraph ACMESky BE[Backend] C[Camunda] R[RabbitMQ] subgraph Camunda-Workers CW1[Payment request] CW2[Verify payment status] end end %%style Camunda-Workers fill:#90EE90 Quando un utente inserisce un codice offerta valido, il worker payment-request contatta il Payment Provider che genera una nuova istanza di pagamento e restituisce al worker il link al quale l'utente pu\u00f2 pagare l'offerta. Il worker pubblica il link sulla coda di RabbitMQ in modo che il frontend possa ottenere il link da mostrare all'utente. Quando l'utente effettua il pagamento sul sito del Payment Provider , il suo esito viene mandato al backend di ACMESky all'URL indicato al momento della creazione della richiesta di pagamento; quando il backend riceve l'esito del pagamento crea un nuovo messaggio che manda a Camunda, che si occuper\u00e0 di far avanzare il processo in modo che il worker verify-payment-status possa valutare l'esito del pagamento appena effettuato. ProntoGram graph TD CW1 -->|POST /messages| PG[ProntoGram] subgraph ACMESky subgraph Camunda-Workers CW1[Notify user via ProntoGram] end end %%style Camunda-Workers fill:#90EE90 Quando viene trovata un'offerta che combacia con l'interesse da parte di un utente viene generato un \"codice offerta\" che viene mandato a ProntoGram indicando il nome utente al quale va recapitato. Torna a Implementazione .","title":"ACMESky"},{"location":"implementazione/acmesky/#panoramica","text":"graph TD CW --> DBs CW --> OS[Altri servizi] CW --> C CW --> R BE --> C FE --> BE FE --> MW Utente --> FE MW --> R subgraph ACMESky DBs(Database) CW[Camunda Workers] C[Camunda] BE[Backend] R[RabbitMQ] FE[Frontend] MW[Middleware] end ACMESky \u00e8 l'insieme di servizi che permettono ad un utente di inserire un proprio interesse all'interno del sistema e di acquistare i voli per un viaggio.","title":"Panoramica"},{"location":"implementazione/acmesky/#interazioni-utente-e-acmesky","text":"graph LR BE -->|Correlate messages| C FE -->|POST /offers/buy| BE FE -->|POST /interests| BE FE -->|WebSocket| MW Utente --> FE MW -->|Subscribe| R subgraph ACMESky C[Camunda] BE[Backend] R[RabbitMQ] FE[Frontend] MW[Middleware] end L'utente interagisce con l'interfaccia web messa a disposizione dal frontend. Il frontend mette a disposizione due funzionalit\u00e0, l'aggiunta di un nuovo interesse e l'acquisto di un viaggio. Queste due operazioni sono permesse da due chiamate HTTP al backend di ACMESky : POST /interests e POST /offers/buy . Homepage ACMESky","title":"Interazioni Utente e ACMESky"},{"location":"implementazione/acmesky/#aggiunta-di-un-nuovo-interesse","text":"Aggiunta di un nuovo interesse Un utente per aggiungere il proprio interesse inserisce i dati richiesti e preme il pulsante \"Conferma\". I dati del modulo vengono inviati al backend che, a sua volta, li invia a Camunda, avviando cos\u00ec una nuova istanza del business process Registrazione interesse utente nell'engine; i cui task verranno svolti dai worker assegnati, tra i quali il worker register-interest , che aggiunge l'interesse all'interno di MongoDB. Verr\u00e0 fatto nuovamente riferimento a questo database quando verranno controllati gli interessi non ancora soddisfatti alla ricerca di offerte che soddisfano i requisiti salvati.","title":"Aggiunta di un nuovo interesse"},{"location":"implementazione/acmesky/#acquisto-di-unofferta","text":"Inserimento dati acquisto offerta Quando un utente riceve il codice offerta tramite ProntoGram si pu\u00f2 recare su questa pagine e, riempiendo il form con i dati richiesti, avviare il processo di acquisto di un'offerta. Il frontend contatta il backend passandogli i dati inseriti dall'utente e, a sua volta, invia un messaggio a Camunda che avvia una nuova istanza del processo di business Acquisto offerta da un utente . Il backend risponde con il codice che verr\u00e0 usato per la comunicazione tra frontend e middleware tramite WebSocket. Quando un worker deve comunicare con il frontend, pubblica un messaggio sulla coda RabbitMQ utilizzando lo stesso codice comunicato al frontend. Il middleware, essendosi sottoscritto alla stessa coda, utilizza il WebSocket per comunicare il messaggio al giusto utente. In questo modo \u00e8 possibile: comunicare errori: Comunicazione errori al Frontend richiedere il pagamento da parte dell'utente: Richiesta pagamento mostrare l'offerta acquistata: Biglietti acquistati","title":"Acquisto di un'offerta"},{"location":"implementazione/acmesky/#interazioni-acmesky-e-servizi-esterni","text":"Per poter compiere i diversi task, i worker contattano dei servizi che sono esterni ad ACMESky . graph LR CW --> FC[Flight Company] CW --> TC[Travel Company] CW --> GD[Geographical distances] CW --> PP[Payment Provider] CW --> PG[ProntoGram] subgraph ACMESky CW[Camunda Workers] end subgraph Servizi-Esterni FC[Flight Company] TC[Travel Company] GD[Geographical distances] PP[Payment Provider] PG[ProntoGram] end Per interagire con i servizi RESTful esterni \u00e8 stata utilizzata la libreria Requests di Python che permette in maniera molto semplice di soddisfare la necessit\u00e0 di fare chiamate HTTP POST e GET : get_response = requests.get(url) post_response = requests.post(url, json=dict_representing_the_json)","title":"Interazioni ACMESky e servizi esterni"},{"location":"implementazione/acmesky/#flight-company","text":"graph TD CW1 -->|POST /flights/buy| FC[Flight Company] CW2 -->|GET /flights/offers| FC[Flight Company] FC[Flight Company] -->|POST /offers/lastminute|B subgraph ACMESky B[Backend] subgraph Camunda-Workers CW1[Buy flights] CW2[Get flight offers] end end %%style Camunda-Workers fill:#90EE90 ACMESky comunica con le Flight Company tramite chiamate HTTP. Quando devo effettuare l'acquisto di uno o pi\u00f9 voli invia un documento in formato JSON come corpo della richiesta all'endpoint POST /flights/buy mentre, una volta al giorno contatta l'endpoint GET /flights/offers per ottenere la lista di voli aggiunti nelle ultime 24h, ovvero quando Camunda avvia il business process Verifica giornaliera delle offerte Quando un nuovo volo viene aggiunto ad una compagnia aerea, questo viene, a sua volta, inviato anche ad ACMESky tramite l'endpoint POST /offers/lastminute","title":"Flight Company"},{"location":"implementazione/acmesky/#travel-company","text":"graph TD CW1 -->|Retrieve travelcompany.wsdl| TCf CW1 -->|SOAP buyTransfer| TC subgraph ACMESky subgraph Camunda-Workers CW1[Book transfer] end end subgraph Travel-Companies TC[Jolie service] TCf[Travel Company file provider] end %%style Camunda-Workers fill:#90EE90 Quando ACMESky deve prenotare il trasferimento da/verso casa dell'utente e aeroporto utilizza la libreria Zeep che \u00e8 in grado di generare un client SOAP a partire dal file WSDL che descrive il servizio. soap_client = Client(wsdl=wsdl_url) soap_response = soap_client.service.buyTransfers( departure_transfer_datetime=outbound_departure_transfer_datetime.strftime(\"%Y-%m-%dT%H:%M:%S\"), customer_address=str(offer_purchase_data.address), airport_code=offer_match.outbound_flight.departure_airport_code, customer_name=f\"{offer_purchase_data.name} {offer_purchase_data.surname}\", arrival_transfer_datetime=comeback_arrival_transfer_datetime.strftime(\"%Y-%m-%dT%H:%M:%S\") )","title":"Travel Company"},{"location":"implementazione/acmesky/#geographical-distances","text":"graph TD CW1 -->|POST /distance| GD[Geographical Distances] CW2 -->|POST /distance| GD[Geographical Distances] subgraph ACMESky subgraph Camunda-Workers CW1[Check distance house airport] CW2[Get min distance house travel company] end end %%style Camunda-Workers fill:#90EE90 ACMESky utilizza il servizio per il calcolo delle distanze geografiche per calcolare la distanza tra due indirizzi. Il servizio \u00e8 contattato due volte: quando c'\u00e8 da calcolare la distanza tra la casa del cliente e l'aeroporto e per trovare la compagnia di trasporto pi\u00f9 vicina alla casa del cliente.","title":"Geographical distances"},{"location":"implementazione/acmesky/#payment-provider","text":"graph TD CW1 -->|POST /payments/request| PP[Payment Provider] CW1 -->|Publish payment URL|R PP[Payment Provider] -->|POST /payments| BE BE -->|Send correlate message| C CW2 -->|Polling for new task| C subgraph ACMESky BE[Backend] C[Camunda] R[RabbitMQ] subgraph Camunda-Workers CW1[Payment request] CW2[Verify payment status] end end %%style Camunda-Workers fill:#90EE90 Quando un utente inserisce un codice offerta valido, il worker payment-request contatta il Payment Provider che genera una nuova istanza di pagamento e restituisce al worker il link al quale l'utente pu\u00f2 pagare l'offerta. Il worker pubblica il link sulla coda di RabbitMQ in modo che il frontend possa ottenere il link da mostrare all'utente. Quando l'utente effettua il pagamento sul sito del Payment Provider , il suo esito viene mandato al backend di ACMESky all'URL indicato al momento della creazione della richiesta di pagamento; quando il backend riceve l'esito del pagamento crea un nuovo messaggio che manda a Camunda, che si occuper\u00e0 di far avanzare il processo in modo che il worker verify-payment-status possa valutare l'esito del pagamento appena effettuato.","title":"Payment Provider"},{"location":"implementazione/acmesky/#prontogram","text":"graph TD CW1 -->|POST /messages| PG[ProntoGram] subgraph ACMESky subgraph Camunda-Workers CW1[Notify user via ProntoGram] end end %%style Camunda-Workers fill:#90EE90 Quando viene trovata un'offerta che combacia con l'interesse da parte di un utente viene generato un \"codice offerta\" che viene mandato a ProntoGram indicando il nome utente al quale va recapitato. Torna a Implementazione .","title":"ProntoGram"},{"location":"implementazione/flightcompany/","text":"Torna a Implementazione . Panoramica graph TB FC1 -->|POST /offers| AS3 AS1 -->|POST /flights/buy| FC1 AS2 -->|POST /flights/offers| FC1 subgraph TravelCompany FC1[Flight Company service] FC2(Flight Company DB) FC1 --> FC2 end subgraph ACMESky subgraph Camunda-Workers AS1[Buy Flights] AS2[Get Flight Offers] end AS3[Backend] end %%style Camunda-Workers fill:#90EE90 Flight Company \u00e8 il servizio che permette di acquistare il proprio biglietto per i voli della compagnia aerea, permette di ottenere una lista dei voli e notificare ad ACMESky la presenza di offerte last minute. L'utente non vi interagisce direttamente, in quanto qualsiasi contatto viene fatto in automatico da parte di ACMESky . In particolare, sono i worker buy-flights , get-flight-offers e check-offers-presence ad occuparsene. Nella rete accessibile ai servizi ci sono 3 istanze di Flight Company ( flight_company_1 , flight_company_2 , flight_company_3 ) che si comportano tutte nella medesima maniera. Non essendo la parte principale di questo progetto, le flight company sono state implementate in maniera basilare. Il servizio mette a disposizione due endpoint utilizzati da ACMESky per interagirci: POST /flights/buy che nel corpo del messaggio contiene i voli il cui biglietto \u00e8 da acquistare. La flight company controlla la correttezza dei dati inviati e aggiorna il record del volo nel database, incrementando il numero di biglietti acquistati ed infine ritornare l'esito dell'operazione; POST /flights/offers che restituisce l'elenco dei voli disponibili nella compagnia aerea che sono stati aggiunti nelle ultime 24h. Il database contiene la lista dei voli disponibili per la compagnia aerea, viene interrogato per ottenere i voli aggiunti nelle ultime 24h e per aggiornare il numero di biglietti venduti quando ne viene acquistato uno. Torna a Implementazione .","title":"Flight Company"},{"location":"implementazione/flightcompany/#panoramica","text":"graph TB FC1 -->|POST /offers| AS3 AS1 -->|POST /flights/buy| FC1 AS2 -->|POST /flights/offers| FC1 subgraph TravelCompany FC1[Flight Company service] FC2(Flight Company DB) FC1 --> FC2 end subgraph ACMESky subgraph Camunda-Workers AS1[Buy Flights] AS2[Get Flight Offers] end AS3[Backend] end %%style Camunda-Workers fill:#90EE90 Flight Company \u00e8 il servizio che permette di acquistare il proprio biglietto per i voli della compagnia aerea, permette di ottenere una lista dei voli e notificare ad ACMESky la presenza di offerte last minute. L'utente non vi interagisce direttamente, in quanto qualsiasi contatto viene fatto in automatico da parte di ACMESky . In particolare, sono i worker buy-flights , get-flight-offers e check-offers-presence ad occuparsene. Nella rete accessibile ai servizi ci sono 3 istanze di Flight Company ( flight_company_1 , flight_company_2 , flight_company_3 ) che si comportano tutte nella medesima maniera. Non essendo la parte principale di questo progetto, le flight company sono state implementate in maniera basilare. Il servizio mette a disposizione due endpoint utilizzati da ACMESky per interagirci: POST /flights/buy che nel corpo del messaggio contiene i voli il cui biglietto \u00e8 da acquistare. La flight company controlla la correttezza dei dati inviati e aggiorna il record del volo nel database, incrementando il numero di biglietti acquistati ed infine ritornare l'esito dell'operazione; POST /flights/offers che restituisce l'elenco dei voli disponibili nella compagnia aerea che sono stati aggiunti nelle ultime 24h. Il database contiene la lista dei voli disponibili per la compagnia aerea, viene interrogato per ottenere i voli aggiunti nelle ultime 24h e per aggiornare il numero di biglietti venduti quando ne viene acquistato uno. Torna a Implementazione .","title":"Panoramica"},{"location":"implementazione/geodistances/","text":"Torna a Implementazione . Panoramica graph LR ACMESky -->|POST /distance| GD[Geographical Distances API] GD[Geographical Distances API] -->|Geocoding| OpenCage Geographical Distances \u00e8 il servizio che permette ad ACMESky di verificare la distanza fra due luoghi, in modo tale da sapere se dover fornire all'utente un ulteriore servizio di trasporto da e verso l'aeroporto oppure no. \u00c8 stato implementato in maniera molto semplice ma, al tempo stesso, esaustiva e il pi\u00f9 possibile corretta. Infatti, il servizio funziona nel seguente modo: il client ( ACMESky in questo caso) contatta il servizio mediante le API fornite, in particolare attraverso POST /distance , specificando nel corpo della richiesta gli indirizzi dei due luoghi geografici di cui calcolare la distanza; non c'\u00e8 un formato particolare richiesto per gli indirizzi da dare in input alle API ma, pi\u00f9 precisi e completi sono, migliore \u00e8 il risultato; gli indirizzi dei luoghi vengono trasformati in coordinate GPS tramite un processo di geocoding , ossia di conversione da indirizzo testuale a posizione GPS (longitudine, latitudine); per fare ci\u00f2 ci siamo appoggiati a un servizio esterno disponibile gratuitamente (come free trial , abbondantemente sufficiente per gli scopi di questo progetto didattico) chiamato OpenCage ; il geocoding fornito da OpenCage cerca di restituire sempre qualcosa, cercando di trovare una coppia (longitudine, latitudine) anche su sottostringhe dell'indirizzo fornito; per assicurare che non avvengano errori, nell'interfaccia utente di ACMESky obblighiamo l'utente a inserire almeno la nazione da cui parte corretta (poich\u00e9 forniamo la lista completa delle nazioni mediante un menu a tendina); una volta ottenute le due coppie (longitudine, latitudine) relative agli indirizzi di partenza, esse vengono utilizzate per calcolare la distanza di Haversine (in Km) fra i due punti, che corrisponde alla distanza in linea d'aria di due punti su di una superficie sferica (\u00e8 un'approssimazione visto che la Terra non \u00e8 esattamente una sfera ma, per distanze ridotte come nel caso in esame, non \u00e8 un grave problema). Torna a Implementazione","title":"Geographical Distances"},{"location":"implementazione/geodistances/#panoramica","text":"graph LR ACMESky -->|POST /distance| GD[Geographical Distances API] GD[Geographical Distances API] -->|Geocoding| OpenCage Geographical Distances \u00e8 il servizio che permette ad ACMESky di verificare la distanza fra due luoghi, in modo tale da sapere se dover fornire all'utente un ulteriore servizio di trasporto da e verso l'aeroporto oppure no. \u00c8 stato implementato in maniera molto semplice ma, al tempo stesso, esaustiva e il pi\u00f9 possibile corretta. Infatti, il servizio funziona nel seguente modo: il client ( ACMESky in questo caso) contatta il servizio mediante le API fornite, in particolare attraverso POST /distance , specificando nel corpo della richiesta gli indirizzi dei due luoghi geografici di cui calcolare la distanza; non c'\u00e8 un formato particolare richiesto per gli indirizzi da dare in input alle API ma, pi\u00f9 precisi e completi sono, migliore \u00e8 il risultato; gli indirizzi dei luoghi vengono trasformati in coordinate GPS tramite un processo di geocoding , ossia di conversione da indirizzo testuale a posizione GPS (longitudine, latitudine); per fare ci\u00f2 ci siamo appoggiati a un servizio esterno disponibile gratuitamente (come free trial , abbondantemente sufficiente per gli scopi di questo progetto didattico) chiamato OpenCage ; il geocoding fornito da OpenCage cerca di restituire sempre qualcosa, cercando di trovare una coppia (longitudine, latitudine) anche su sottostringhe dell'indirizzo fornito; per assicurare che non avvengano errori, nell'interfaccia utente di ACMESky obblighiamo l'utente a inserire almeno la nazione da cui parte corretta (poich\u00e9 forniamo la lista completa delle nazioni mediante un menu a tendina); una volta ottenute le due coppie (longitudine, latitudine) relative agli indirizzi di partenza, esse vengono utilizzate per calcolare la distanza di Haversine (in Km) fra i due punti, che corrisponde alla distanza in linea d'aria di due punti su di una superficie sferica (\u00e8 un'approssimazione visto che la Terra non \u00e8 esattamente una sfera ma, per distanze ridotte come nel caso in esame, non \u00e8 un grave problema). Torna a Implementazione","title":"Panoramica"},{"location":"implementazione/paymentprovider/","text":"Torna a Implementazione . Panoramica graph LR Utente -->|Apertura link fornito da ACMESky| UI[Interfaccia utente] Utente -->|Compilazione modulo di pagamento| UI[Interfaccia utente] subgraph Frontend UI[Interfaccia utente] end graph LR ACMESky -->|POST /payments/request| PP[Payment Provider API] subgraph Backend PP[Payment Provider API] -->|\"Salvataggio (transaction_id, richiesta pagamento)\"| Redis PP[Payment Provider API] -->|Recupero richiesta tramite transaction_id| Redis end subgraph Frontend UI[Interfaccia utente] -->|\"GET /payments/{transaction_id}\"| PP[Payment Provider API] UI[Interfaccia utente] -->|POST /payments/pay| PP[Payment Provider API] end Payment Provider \u00e8 il servizio che permette: ad ACMESky di avere un intermediario per la gestione dei pagamenti delle offerte da parte dei suoi utenti; all'utente di pagare tali offerte tramite carta di credito. \u00c8 stato implementato in maniera semplice ma, al tempo stesso, esaustiva e il pi\u00f9 possibile realistica, emulando quanto avviene in altri intermediari di pagamento commerciali. Dal punto di vista di ACMESky , il Payment Provider permette di: creare una richiesta di pagamento, specificando chi \u00e8 il ricevente del denaro (ovvero ACMESky stessa), l'importo e una breve descrizione per assicurare l'utente di stare pagando ci\u00f2 che si aspetta; ricevere un URL da fornire all'utente, per permettere il pagamento, una volta aver correttamente creato la richiesta; essere contattato quando un pagamento viene completato, in modo da poter procedere nel processo di acquisto dell'offerta. Dal punto di vista dell'utente, il Payment Provider permette di: ricevere i dettagli della richiesta di pagamento elaborata da ACMESky attraverso una pagina web, il cui URL, \u00e8 stato precedentemente fornito ad ACMESky ; inserire i dati di pagamento nella pagina sopracitata e, se sono corretti, inviare il pagamento (ovviamente il pagamento non \u00e8 assolutamente reale); verificare il codice della carta di credito mediante la formula di Luhn ; generare un errore nel pagamento nel caso il CVV inserito sia 456 (non \u00e8 ovviamente n\u00e9 realistico n\u00e9 una funzionalit\u00e0 di interesse per l'utente, \u00e8 solo un modo per permettere la generazione di errori in maniera controllata e verificare il corretto funzionamento del sistema anche in queste situazioni). Pagamento tramite Payment Provider Torna a Implementazione .","title":"Payment Provider"},{"location":"implementazione/paymentprovider/#panoramica","text":"graph LR Utente -->|Apertura link fornito da ACMESky| UI[Interfaccia utente] Utente -->|Compilazione modulo di pagamento| UI[Interfaccia utente] subgraph Frontend UI[Interfaccia utente] end graph LR ACMESky -->|POST /payments/request| PP[Payment Provider API] subgraph Backend PP[Payment Provider API] -->|\"Salvataggio (transaction_id, richiesta pagamento)\"| Redis PP[Payment Provider API] -->|Recupero richiesta tramite transaction_id| Redis end subgraph Frontend UI[Interfaccia utente] -->|\"GET /payments/{transaction_id}\"| PP[Payment Provider API] UI[Interfaccia utente] -->|POST /payments/pay| PP[Payment Provider API] end Payment Provider \u00e8 il servizio che permette: ad ACMESky di avere un intermediario per la gestione dei pagamenti delle offerte da parte dei suoi utenti; all'utente di pagare tali offerte tramite carta di credito. \u00c8 stato implementato in maniera semplice ma, al tempo stesso, esaustiva e il pi\u00f9 possibile realistica, emulando quanto avviene in altri intermediari di pagamento commerciali. Dal punto di vista di ACMESky , il Payment Provider permette di: creare una richiesta di pagamento, specificando chi \u00e8 il ricevente del denaro (ovvero ACMESky stessa), l'importo e una breve descrizione per assicurare l'utente di stare pagando ci\u00f2 che si aspetta; ricevere un URL da fornire all'utente, per permettere il pagamento, una volta aver correttamente creato la richiesta; essere contattato quando un pagamento viene completato, in modo da poter procedere nel processo di acquisto dell'offerta. Dal punto di vista dell'utente, il Payment Provider permette di: ricevere i dettagli della richiesta di pagamento elaborata da ACMESky attraverso una pagina web, il cui URL, \u00e8 stato precedentemente fornito ad ACMESky ; inserire i dati di pagamento nella pagina sopracitata e, se sono corretti, inviare il pagamento (ovviamente il pagamento non \u00e8 assolutamente reale); verificare il codice della carta di credito mediante la formula di Luhn ; generare un errore nel pagamento nel caso il CVV inserito sia 456 (non \u00e8 ovviamente n\u00e9 realistico n\u00e9 una funzionalit\u00e0 di interesse per l'utente, \u00e8 solo un modo per permettere la generazione di errori in maniera controllata e verificare il corretto funzionamento del sistema anche in queste situazioni). Pagamento tramite Payment Provider Torna a Implementazione .","title":"Panoramica"},{"location":"implementazione/prontogram/","text":"Torna a Implementazione . Panoramica graph LR subgraph Frontend UI[Interfaccia utente] -->|Fetch| WebSocket Flask[Web server] -->|Push| WebSocket end Flask[Web server] -->|Subscribe| MQ[RabbitMQ] ACMESky -->|POST /messages| PG[ProntoGram API] subgraph Backend PG[ProntoGram API] -->|Publish| MQ[RabbitMQ] end ProntoGram \u00e8 il servizio che permette agli utenti di ricevere i codici offerta sotto forma di messaggio testuale. Gli utenti ricevono un messaggio ogni qual volta ACMESky trova per loro degli interessi di viaggi di cui avevano fatto richiesta. Non essendo la parte principale di questo progetto didattico, ProntoGram \u00e8 stato implementato in maniera molto basilare. In particolare, l'utente tramite questa implementazione, ha la possibilit\u00e0 di: accedere, tramite una pagina web, al servizio di messaggistica e autenticarsi mediante un nome utente (non vi \u00e8 alcuna password richiesta); Pagina di login di ProntoGram una volta che l'utente ha avuto accesso, pu\u00f2 visualizzare tutti i messaggi che sono stati ricevuti quando non era connesso e visualizzarli in tempo reale se ACMESky dovesse inviargliene alcuni mentre \u00e8 collegato; i messaggi hanno una durata temporale limitata e non vengono pi\u00f9 memorizzati una volta visualizzati (la persistenza del messaggio dura fino alla sua visualizzazione e, da quel momento, esso viene cancellato dal supporto persistente). Ricezione messaggio Il funzionamento di ProntoGram dipende in larga parte dalla decisione di utilizzo del design pattern Publish/Subscribe e delle cosiddette WebSocket : ACMESky , quando ha un'offerta da comunicare ad un utente, invia un messaggio contattando l'endpoint delle API RESTful di ProntoGram ( POST /messages ); ricevuta la richiesta di ACMESky , internamente ProntoGram pubblica il messaggio in una coda ( messaging queue ) fornita dal software RabbitMQ , avente come identificatore il ricevente indicato nel messaggio ricevuto (parte Publish del pattern); se l'utente ha avuto accesso alla pagina web di ProntoGram e sta visualizzando la propria lista di messaggi allora \u00e8 aperta una WebSocket (implementata attraverso il software Socket.IO ) collegata alla coda in RabbitMQ, conseguentemente il contenuto della pagina web si aggiorna automaticamente consumando il messaggio pubblicato nella WebSocket il quale, precedentemente, lo aveva consumato dalla coda RabbitMQ (parte Subscribe del pattern); se l'utente non ha avuto accesso allora il messaggio persiste nella coda di RabbitMQ fino al suo consumo, come descritto in precedenza. Torna a Implementazione .","title":"ProntoGram"},{"location":"implementazione/prontogram/#panoramica","text":"graph LR subgraph Frontend UI[Interfaccia utente] -->|Fetch| WebSocket Flask[Web server] -->|Push| WebSocket end Flask[Web server] -->|Subscribe| MQ[RabbitMQ] ACMESky -->|POST /messages| PG[ProntoGram API] subgraph Backend PG[ProntoGram API] -->|Publish| MQ[RabbitMQ] end ProntoGram \u00e8 il servizio che permette agli utenti di ricevere i codici offerta sotto forma di messaggio testuale. Gli utenti ricevono un messaggio ogni qual volta ACMESky trova per loro degli interessi di viaggi di cui avevano fatto richiesta. Non essendo la parte principale di questo progetto didattico, ProntoGram \u00e8 stato implementato in maniera molto basilare. In particolare, l'utente tramite questa implementazione, ha la possibilit\u00e0 di: accedere, tramite una pagina web, al servizio di messaggistica e autenticarsi mediante un nome utente (non vi \u00e8 alcuna password richiesta); Pagina di login di ProntoGram una volta che l'utente ha avuto accesso, pu\u00f2 visualizzare tutti i messaggi che sono stati ricevuti quando non era connesso e visualizzarli in tempo reale se ACMESky dovesse inviargliene alcuni mentre \u00e8 collegato; i messaggi hanno una durata temporale limitata e non vengono pi\u00f9 memorizzati una volta visualizzati (la persistenza del messaggio dura fino alla sua visualizzazione e, da quel momento, esso viene cancellato dal supporto persistente). Ricezione messaggio Il funzionamento di ProntoGram dipende in larga parte dalla decisione di utilizzo del design pattern Publish/Subscribe e delle cosiddette WebSocket : ACMESky , quando ha un'offerta da comunicare ad un utente, invia un messaggio contattando l'endpoint delle API RESTful di ProntoGram ( POST /messages ); ricevuta la richiesta di ACMESky , internamente ProntoGram pubblica il messaggio in una coda ( messaging queue ) fornita dal software RabbitMQ , avente come identificatore il ricevente indicato nel messaggio ricevuto (parte Publish del pattern); se l'utente ha avuto accesso alla pagina web di ProntoGram e sta visualizzando la propria lista di messaggi allora \u00e8 aperta una WebSocket (implementata attraverso il software Socket.IO ) collegata alla coda in RabbitMQ, conseguentemente il contenuto della pagina web si aggiorna automaticamente consumando il messaggio pubblicato nella WebSocket il quale, precedentemente, lo aveva consumato dalla coda RabbitMQ (parte Subscribe del pattern); se l'utente non ha avuto accesso allora il messaggio persiste nella coda di RabbitMQ fino al suo consumo, come descritto in precedenza. Torna a Implementazione .","title":"Panoramica"},{"location":"implementazione/travelcompany/","text":"Torna a Implementazione . Panoramica graph LR AS[Book Transfer] -->|Get flightcompany.wsdl| TC1[WSDL file provider] AS[Book Transfer] -->|SOAP request/response 'buyTransfer'| TC[Jolie service] subgraph ACMESky subgraph Camunda-Workers AS[Book Transfer] end end subgraph TravelCompany TC1[WSDL file provider] TC[Jolie service] end %%style Camunda-Workers fill:#90EE90 Travel Company \u00e8 il servizio che permette di prenotare il trasposto da/verso l'aeroporto e la casa del cliente. L'utente non vi interagisce direttamente in quanto qualsiasi contatto viene fatto in automatico da parte di ACMESky , in particolare \u00e8 il worker book-transfer ad occuparsi di questo task. Nella rete accessibile ai servizi vi sono 3 istanze di Travel Company ( travel_company_1 , travel_company_2 , travel_company_3 ) che si comportano tutte nella medesima maniera. Non essendo la parte principale di questo progetto didattico, le Travel Company sono state implementate in maniera molto basilare. Il container Docker che contiene i servizi espone anche il file WSDL che descrive il servizio in modo da poterci interagire tramite protocollo SOAP. Dal punto di vista di ACMESky , le Travel Company permettono di prenotare il trasferimento di andata e ritorno dalla casa del cliente all'aeroporto. La Travel Company controlla che le date di andata venga prima di quella di ritorno e, se non ci sono errori, restituisce un messaggio che certifica che i trasferimenti sono stati prenotati correttamente. Torna a Implementazione .","title":"Travel Company"},{"location":"implementazione/travelcompany/#panoramica","text":"graph LR AS[Book Transfer] -->|Get flightcompany.wsdl| TC1[WSDL file provider] AS[Book Transfer] -->|SOAP request/response 'buyTransfer'| TC[Jolie service] subgraph ACMESky subgraph Camunda-Workers AS[Book Transfer] end end subgraph TravelCompany TC1[WSDL file provider] TC[Jolie service] end %%style Camunda-Workers fill:#90EE90 Travel Company \u00e8 il servizio che permette di prenotare il trasposto da/verso l'aeroporto e la casa del cliente. L'utente non vi interagisce direttamente in quanto qualsiasi contatto viene fatto in automatico da parte di ACMESky , in particolare \u00e8 il worker book-transfer ad occuparsi di questo task. Nella rete accessibile ai servizi vi sono 3 istanze di Travel Company ( travel_company_1 , travel_company_2 , travel_company_3 ) che si comportano tutte nella medesima maniera. Non essendo la parte principale di questo progetto didattico, le Travel Company sono state implementate in maniera molto basilare. Il container Docker che contiene i servizi espone anche il file WSDL che descrive il servizio in modo da poterci interagire tramite protocollo SOAP. Dal punto di vista di ACMESky , le Travel Company permettono di prenotare il trasferimento di andata e ritorno dalla casa del cliente all'aeroporto. La Travel Company controlla che le date di andata venga prima di quella di ritorno e, se non ci sono errori, restituisce un messaggio che certifica che i trasferimenti sono stati prenotati correttamente. Torna a Implementazione .","title":"Panoramica"},{"location":"serviziweb/acmesky/","text":"Torna a Servizi web . Panoramica Dentro la rete Docker acmesky-network , tutti gli URI sono relativi a http://acmesky_backend:8080 . Da fuori Docker, la porta per raggiungere il servizio \u00e8 9000 . Risorsa Descrizione Risorsa per POST /offers/buy Richiede l'avvio di un processo di acquisto dell'offerta con il codice offerta passato come argomento. Utente finale POST /offers/lastminute Permette alle compagnie aeree di notificare ACMESky della presenza di nuove offerte last minute. Flight Company POST /interests Registra l'interesse di un utente per la ricezione di offerte di volo A/R. Utente finale POST /payments Invia le informazioni di pagamento ricevute dall'utente a fini di verifica. Payment Provider Richieste POST /offers/buy Richiede l'avvio di un processo di acquisto dell'offerta con il codice offerta passato come argomento. Parametri Nome Tipo OfferPurchaseData OfferPurchaseData Tipo ritornato 200 : BuyOfferResponse 400 : Error Header della richiesta Content-Type : application/json Accept : application/json POST /offers/lastminute Permette alle compagnie aeree di notificare ACMESky della presenza di nuove offerte last minute. Parametri Nome Tipo company_name String Flight List Tipo ritornato 200 : - 400 : - Header della richiesta Content-Type : application/json Accept : application/json POST /interests Registra l'interesse di un utente per la ricezione di offerte di volo A/R. Parametri Nome Tipo Interest Interest Tipo ritornato 200 : - 400 : Error Header della richiesta Content-Type : application/json Accept : application/json POST /payments Invia le informazioni di pagamento ricevute dall'utente a fini di verifica. Parametri Nome Tipo PaymentInformation PaymentInformation Tipo ritornato 200 : - 400 : - Header della richiesta Content-Type : application/json Accept : application/json Modelli Address Nome Tipo street String number String city String zip_code String country String BuyOfferResponse Nome Tipo communication_code String Error Nome Tipo Descrizione String Flight Nome Tipo flight_id String departure_airport_code String arrival_airport_code String cost Double departure_datetime DateTime arrival_datetime DateTime Interest Nome Tipo departure_airport_code String arrival_airport_code String min_departure_date Date max_comeback_date Date max_price Double prontogram_username String OfferPurchaseData Nome Tipo offer_code String address Address name String surname String PaymentInformation Nome Tipo transaction_id UUID status Boolean Interfaccia OpenAPI Nel seguente blocco (cliccare sulla barra con su scritto \"OpenAPI\" in basso per aprirlo) \u00e8 possibile visualizzare l'interfaccia OpenAPI che descrive il funzionamento delle API fornite da ACMESky . OpenAPI openapi : 3.0.0 info : title : ACMESky version : '1.0' description : Interface that models the operations for ACMESky. servers : - url : 'http://acmesky_backend:8080' description : Inside the docker network - url : 'http://chosen_url:9000' description : Outside the Docker network (chosen_url is a placeholder) paths : /offers/lastminute : post : summary : publishLastMinuteOffer operationId : publishLastMinuteOffer responses : '200' : description : OK '400' : description : Bad Request description : |- Allows flight companies to notify ACMESky of the presence of new last minute offers. API for: Flight Company requestBody : content : application/json : schema : type : array items : $ref : '#/components/schemas/Flight' parameters : - schema : type : string in : query name : company_name description : Name of the flight company required : true parameters : [] /offers/buy : post : summary : buyOffer operationId : buyOffer responses : '200' : description : OK content : application/json : schema : $ref : '#/components/schemas/BuyOfferResponse' '400' : description : Bad Request content : application/json : schema : $ref : '#/components/schemas/Error' description : |- Requires to start the buying process of the offer with the given offer code. API for: User parameters : [] requestBody : content : application/json : schema : $ref : '#/components/schemas/OfferPurchaseData' description : '' /payments : post : summary : sendPaymentInformation operationId : sendPaymentInformation responses : '200' : description : OK '400' : description : Bad Request description : |- Sends the information received by the user for verification purposes. API for: Payment Provider requestBody : content : application/json : schema : $ref : '#/components/schemas/PaymentInformation' description : '' /interests : post : summary : registerInterest operationId : registerInterest responses : '200' : description : OK '400' : description : Bad Request content : application/json : schema : $ref : '#/components/schemas/Error' requestBody : content : application/json : schema : $ref : '#/components/schemas/Interest' description : |- Register the user interest for roundtrip flights. API for: User components : schemas : Flight : title : Flight type : object properties : flight_id : type : string departure_airport_code : type : string pattern : '[A-Z]{3,3}' arrival_airport_code : type : string pattern : '[A-Z]{3,3}' cost : type : number format : double minimum : 0 departure_datetime : type : string format : date-time arrival_datetime : type : string format : date-time required : - flight_id - departure_airport_code - arrival_airport_code - cost - departure_datetime - arrival_datetime OfferPurchaseData : title : OfferPurchaseData type : object properties : offer_code : type : string minLength : 1 address : $ref : '#/components/schemas/Address' name : type : string minLength : 1 surname : type : string minLength : 1 required : - offer_code - address - name - surname Address : title : Address type : object properties : street : type : string number : type : string city : type : string zip_code : type : string country : type : string required : - street - number - city - zip_code - country PaymentInformation : title : PaymentInformation type : object properties : transaction_id : type : string format : uuid status : type : boolean required : - transaction_id - status Interest : title : Interest type : object properties : departure_airport_code : type : string pattern : '[A-Z]{3,3}' arrival_airport_code : type : string pattern : '[A-Z]{3,3}' min_departure_date : type : string format : date max_comeback_date : type : string format : date max_price : type : number format : double minimum : 0 prontogram_username : type : string minLength : 1 required : - departure_airport_code - arrival_airport_code - min_departure_date - max_comeback_date - max_price - prontogram_username Error : title : Error type : object properties : description : type : string minLength : 1 required : - description BuyOfferResponse : title : BuyOfferResponse type : object properties : communication_code : type : string minLength : 1 required : - communication_code Torna a Servizi web .","title":"ACMESky"},{"location":"serviziweb/acmesky/#panoramica","text":"Dentro la rete Docker acmesky-network , tutti gli URI sono relativi a http://acmesky_backend:8080 . Da fuori Docker, la porta per raggiungere il servizio \u00e8 9000 . Risorsa Descrizione Risorsa per POST /offers/buy Richiede l'avvio di un processo di acquisto dell'offerta con il codice offerta passato come argomento. Utente finale POST /offers/lastminute Permette alle compagnie aeree di notificare ACMESky della presenza di nuove offerte last minute. Flight Company POST /interests Registra l'interesse di un utente per la ricezione di offerte di volo A/R. Utente finale POST /payments Invia le informazioni di pagamento ricevute dall'utente a fini di verifica. Payment Provider","title":"Panoramica"},{"location":"serviziweb/acmesky/#richieste","text":"","title":"Richieste"},{"location":"serviziweb/acmesky/#post-offersbuy","text":"Richiede l'avvio di un processo di acquisto dell'offerta con il codice offerta passato come argomento.","title":"POST /offers/buy"},{"location":"serviziweb/acmesky/#parametri","text":"Nome Tipo OfferPurchaseData OfferPurchaseData","title":"Parametri"},{"location":"serviziweb/acmesky/#tipo-ritornato","text":"200 : BuyOfferResponse 400 : Error","title":"Tipo ritornato"},{"location":"serviziweb/acmesky/#header-della-richiesta","text":"Content-Type : application/json Accept : application/json","title":"Header della richiesta"},{"location":"serviziweb/acmesky/#post-offerslastminute","text":"Permette alle compagnie aeree di notificare ACMESky della presenza di nuove offerte last minute.","title":"POST /offers/lastminute"},{"location":"serviziweb/acmesky/#parametri_1","text":"Nome Tipo company_name String Flight List","title":"Parametri"},{"location":"serviziweb/acmesky/#tipo-ritornato_1","text":"200 : - 400 : -","title":"Tipo ritornato"},{"location":"serviziweb/acmesky/#header-della-richiesta_1","text":"Content-Type : application/json Accept : application/json","title":"Header della richiesta"},{"location":"serviziweb/acmesky/#post-interests","text":"Registra l'interesse di un utente per la ricezione di offerte di volo A/R.","title":"POST /interests"},{"location":"serviziweb/acmesky/#parametri_2","text":"Nome Tipo Interest Interest","title":"Parametri"},{"location":"serviziweb/acmesky/#tipo-ritornato_2","text":"200 : - 400 : Error","title":"Tipo ritornato"},{"location":"serviziweb/acmesky/#header-della-richiesta_2","text":"Content-Type : application/json Accept : application/json","title":"Header della richiesta"},{"location":"serviziweb/acmesky/#post-payments","text":"Invia le informazioni di pagamento ricevute dall'utente a fini di verifica.","title":"POST /payments"},{"location":"serviziweb/acmesky/#parametri_3","text":"Nome Tipo PaymentInformation PaymentInformation","title":"Parametri"},{"location":"serviziweb/acmesky/#tipo-ritornato_3","text":"200 : - 400 : -","title":"Tipo ritornato"},{"location":"serviziweb/acmesky/#header-della-richiesta_3","text":"Content-Type : application/json Accept : application/json","title":"Header della richiesta"},{"location":"serviziweb/acmesky/#modelli","text":"","title":"Modelli"},{"location":"serviziweb/acmesky/#address","text":"Nome Tipo street String number String city String zip_code String country String","title":"Address"},{"location":"serviziweb/acmesky/#buyofferresponse","text":"Nome Tipo communication_code String","title":"BuyOfferResponse"},{"location":"serviziweb/acmesky/#error","text":"Nome Tipo Descrizione String","title":"Error"},{"location":"serviziweb/acmesky/#flight","text":"Nome Tipo flight_id String departure_airport_code String arrival_airport_code String cost Double departure_datetime DateTime arrival_datetime DateTime","title":"Flight"},{"location":"serviziweb/acmesky/#interest","text":"Nome Tipo departure_airport_code String arrival_airport_code String min_departure_date Date max_comeback_date Date max_price Double prontogram_username String","title":"Interest"},{"location":"serviziweb/acmesky/#offerpurchasedata","text":"Nome Tipo offer_code String address Address name String surname String","title":"OfferPurchaseData"},{"location":"serviziweb/acmesky/#paymentinformation","text":"Nome Tipo transaction_id UUID status Boolean","title":"PaymentInformation"},{"location":"serviziweb/acmesky/#interfaccia-openapi","text":"Nel seguente blocco (cliccare sulla barra con su scritto \"OpenAPI\" in basso per aprirlo) \u00e8 possibile visualizzare l'interfaccia OpenAPI che descrive il funzionamento delle API fornite da ACMESky . OpenAPI openapi : 3.0.0 info : title : ACMESky version : '1.0' description : Interface that models the operations for ACMESky. servers : - url : 'http://acmesky_backend:8080' description : Inside the docker network - url : 'http://chosen_url:9000' description : Outside the Docker network (chosen_url is a placeholder) paths : /offers/lastminute : post : summary : publishLastMinuteOffer operationId : publishLastMinuteOffer responses : '200' : description : OK '400' : description : Bad Request description : |- Allows flight companies to notify ACMESky of the presence of new last minute offers. API for: Flight Company requestBody : content : application/json : schema : type : array items : $ref : '#/components/schemas/Flight' parameters : - schema : type : string in : query name : company_name description : Name of the flight company required : true parameters : [] /offers/buy : post : summary : buyOffer operationId : buyOffer responses : '200' : description : OK content : application/json : schema : $ref : '#/components/schemas/BuyOfferResponse' '400' : description : Bad Request content : application/json : schema : $ref : '#/components/schemas/Error' description : |- Requires to start the buying process of the offer with the given offer code. API for: User parameters : [] requestBody : content : application/json : schema : $ref : '#/components/schemas/OfferPurchaseData' description : '' /payments : post : summary : sendPaymentInformation operationId : sendPaymentInformation responses : '200' : description : OK '400' : description : Bad Request description : |- Sends the information received by the user for verification purposes. API for: Payment Provider requestBody : content : application/json : schema : $ref : '#/components/schemas/PaymentInformation' description : '' /interests : post : summary : registerInterest operationId : registerInterest responses : '200' : description : OK '400' : description : Bad Request content : application/json : schema : $ref : '#/components/schemas/Error' requestBody : content : application/json : schema : $ref : '#/components/schemas/Interest' description : |- Register the user interest for roundtrip flights. API for: User components : schemas : Flight : title : Flight type : object properties : flight_id : type : string departure_airport_code : type : string pattern : '[A-Z]{3,3}' arrival_airport_code : type : string pattern : '[A-Z]{3,3}' cost : type : number format : double minimum : 0 departure_datetime : type : string format : date-time arrival_datetime : type : string format : date-time required : - flight_id - departure_airport_code - arrival_airport_code - cost - departure_datetime - arrival_datetime OfferPurchaseData : title : OfferPurchaseData type : object properties : offer_code : type : string minLength : 1 address : $ref : '#/components/schemas/Address' name : type : string minLength : 1 surname : type : string minLength : 1 required : - offer_code - address - name - surname Address : title : Address type : object properties : street : type : string number : type : string city : type : string zip_code : type : string country : type : string required : - street - number - city - zip_code - country PaymentInformation : title : PaymentInformation type : object properties : transaction_id : type : string format : uuid status : type : boolean required : - transaction_id - status Interest : title : Interest type : object properties : departure_airport_code : type : string pattern : '[A-Z]{3,3}' arrival_airport_code : type : string pattern : '[A-Z]{3,3}' min_departure_date : type : string format : date max_comeback_date : type : string format : date max_price : type : number format : double minimum : 0 prontogram_username : type : string minLength : 1 required : - departure_airport_code - arrival_airport_code - min_departure_date - max_comeback_date - max_price - prontogram_username Error : title : Error type : object properties : description : type : string minLength : 1 required : - description BuyOfferResponse : title : BuyOfferResponse type : object properties : communication_code : type : string minLength : 1 required : - communication_code Torna a Servizi web .","title":"Interfaccia OpenAPI"},{"location":"serviziweb/flightcompany/","text":"Torna a Servizi web . Panoramica Dentro la rete Docker acmesky-network , tutti gli URI sono relativi a: http://flight_company_1:8080 for Flight Company 1; http://flight_company_2:8080 for Flight Company 2; http://flight_company_3:8080 for Flight Company 3. Da fuori Docker, le porte per raggiungere i servizi sono rispettivamente: 7001 , 7002 , 7003 . Risorsa Descrizione Risorsa per POST /flights/buy Acquista i voli richiesti e passati come argomento. ACMESky GET /flights/offers Ritorna le offerte giornaliere della compagnia aerea. ACMESky Richieste POST /flights/buy Acquista i voli richiesti e passati come argomento. Parametri Nome Tipo FlightsToPurchase FlightsToPurchase Tipo di ritorno 200 : - 400 : - Header della richiesta Content-Type : application/json Accept : application/json GET /flights/offers Ritorna le offerte giornaliere della compagnia aerea. Parametri Questo endpoint non richiede alcun parametro. Tipo di ritorno 200 : Flights Header della richiesta Content-Type : application/json Accept : application/json Modelli Flight Nome Tipo flight_id String departure_airport_code String arrival_airport_code String cost Double departure_datetime DateTime arrival_datetime DateTime FlightsToPurchase Nome Tipo flight_requests List Flights Nome Tipo flights List FlightToPurchase Nome Tipo flight_id String date Date Interfaccia OpenAPI Nel seguente blocco (cliccare sulla barra con su scritto \"OpenAPI\" in basso per aprirlo) \u00e8 possibile visualizzare l'interfaccia OpenAPI che descrive il funzionamento delle API fornite da Flight Company. OpenAPI openapi : 3.0.0 info : title : Flight Company version : '1.0' description : Interface that models the operations available for a flight company in ACMESky. servers : - url : 'http://flight_company_1:8080' description : Inside the Docker network (for Flight Company 1) - url : 'http://flight_company_2:8080' description : Inside the Docker network (for Flight Company 2) - url : 'http://flight_company_3:8080' description : Inside the Docker network (for Flight Company 3) - url : 'http://chosen_url:7001' description : Outside the Docker network (for Flight Company 1, chosen_url is a placeholder) - url : 'http://chosen_url:7002' description : Outside the Docker network (for Flight Company 2, chosen_url is a placeholder) - url : 'http://chosen_url:7003' description : Outside the Docker network (for Flight Company 3, chosen_url is a placeholder) paths : /flights/buy : parameters : [] post : summary : buyFlights operationId : buyFlights responses : '200' : description : OK '400' : description : Bad Request description : |- Buys the flights with the given purchase details. API for: ACMESky requestBody : content : application/json : schema : $ref : '#/components/schemas/FlightsToPurchase' description : '' /flights/offers : get : summary : getFlightOffers tags : [] responses : '200' : description : OK content : application/json : schema : $ref : '#/components/schemas/Flights' operationId : getFlightOffers description : |- Returns the daily flight offers of the company. API for: ACMESky components : schemas : Flight : title : Flight type : object properties : flight_id : type : string departure_airport_code : type : string pattern : '[A-Z]{3,3}' arrival_airport_code : type : string pattern : '[A-Z]{3,3}' cost : type : number minimum : 0 format : double departure_datetime : type : string format : date-time arrival_datetime : type : string format : date-time required : - flight_id - departure_airport_code - arrival_airport_code - cost - departure_datetime - arrival_datetime FlightToPurchase : title : FlightToPurchase type : object properties : flight_id : type : string date : type : string format : date required : - flight_id - date Flights : title : Flights type : object properties : flights : type : array items : $ref : '#/components/schemas/Flight' FlightsToPurchase : title : FlightsToPurchase type : object properties : flight_requests : type : array items : $ref : '#/components/schemas/FlightToPurchase' securitySchemes : {} Torna a Servizi web .","title":"Flight Company"},{"location":"serviziweb/flightcompany/#panoramica","text":"Dentro la rete Docker acmesky-network , tutti gli URI sono relativi a: http://flight_company_1:8080 for Flight Company 1; http://flight_company_2:8080 for Flight Company 2; http://flight_company_3:8080 for Flight Company 3. Da fuori Docker, le porte per raggiungere i servizi sono rispettivamente: 7001 , 7002 , 7003 . Risorsa Descrizione Risorsa per POST /flights/buy Acquista i voli richiesti e passati come argomento. ACMESky GET /flights/offers Ritorna le offerte giornaliere della compagnia aerea. ACMESky","title":"Panoramica"},{"location":"serviziweb/flightcompany/#richieste","text":"","title":"Richieste"},{"location":"serviziweb/flightcompany/#post-flightsbuy","text":"Acquista i voli richiesti e passati come argomento.","title":"POST /flights/buy"},{"location":"serviziweb/flightcompany/#parametri","text":"Nome Tipo FlightsToPurchase FlightsToPurchase","title":"Parametri"},{"location":"serviziweb/flightcompany/#tipo-di-ritorno","text":"200 : - 400 : -","title":"Tipo di ritorno"},{"location":"serviziweb/flightcompany/#header-della-richiesta","text":"Content-Type : application/json Accept : application/json","title":"Header della richiesta"},{"location":"serviziweb/flightcompany/#get-flightsoffers","text":"Ritorna le offerte giornaliere della compagnia aerea.","title":"GET /flights/offers"},{"location":"serviziweb/flightcompany/#parametri_1","text":"Questo endpoint non richiede alcun parametro.","title":"Parametri"},{"location":"serviziweb/flightcompany/#tipo-di-ritorno_1","text":"200 : Flights","title":"Tipo di ritorno"},{"location":"serviziweb/flightcompany/#header-della-richiesta_1","text":"Content-Type : application/json Accept : application/json","title":"Header della richiesta"},{"location":"serviziweb/flightcompany/#modelli","text":"","title":"Modelli"},{"location":"serviziweb/flightcompany/#flight","text":"Nome Tipo flight_id String departure_airport_code String arrival_airport_code String cost Double departure_datetime DateTime arrival_datetime DateTime","title":"Flight"},{"location":"serviziweb/flightcompany/#flightstopurchase","text":"Nome Tipo flight_requests List","title":"FlightsToPurchase"},{"location":"serviziweb/flightcompany/#flights","text":"Nome Tipo flights List","title":"Flights"},{"location":"serviziweb/flightcompany/#flighttopurchase","text":"Nome Tipo flight_id String date Date","title":"FlightToPurchase"},{"location":"serviziweb/flightcompany/#interfaccia-openapi","text":"Nel seguente blocco (cliccare sulla barra con su scritto \"OpenAPI\" in basso per aprirlo) \u00e8 possibile visualizzare l'interfaccia OpenAPI che descrive il funzionamento delle API fornite da Flight Company. OpenAPI openapi : 3.0.0 info : title : Flight Company version : '1.0' description : Interface that models the operations available for a flight company in ACMESky. servers : - url : 'http://flight_company_1:8080' description : Inside the Docker network (for Flight Company 1) - url : 'http://flight_company_2:8080' description : Inside the Docker network (for Flight Company 2) - url : 'http://flight_company_3:8080' description : Inside the Docker network (for Flight Company 3) - url : 'http://chosen_url:7001' description : Outside the Docker network (for Flight Company 1, chosen_url is a placeholder) - url : 'http://chosen_url:7002' description : Outside the Docker network (for Flight Company 2, chosen_url is a placeholder) - url : 'http://chosen_url:7003' description : Outside the Docker network (for Flight Company 3, chosen_url is a placeholder) paths : /flights/buy : parameters : [] post : summary : buyFlights operationId : buyFlights responses : '200' : description : OK '400' : description : Bad Request description : |- Buys the flights with the given purchase details. API for: ACMESky requestBody : content : application/json : schema : $ref : '#/components/schemas/FlightsToPurchase' description : '' /flights/offers : get : summary : getFlightOffers tags : [] responses : '200' : description : OK content : application/json : schema : $ref : '#/components/schemas/Flights' operationId : getFlightOffers description : |- Returns the daily flight offers of the company. API for: ACMESky components : schemas : Flight : title : Flight type : object properties : flight_id : type : string departure_airport_code : type : string pattern : '[A-Z]{3,3}' arrival_airport_code : type : string pattern : '[A-Z]{3,3}' cost : type : number minimum : 0 format : double departure_datetime : type : string format : date-time arrival_datetime : type : string format : date-time required : - flight_id - departure_airport_code - arrival_airport_code - cost - departure_datetime - arrival_datetime FlightToPurchase : title : FlightToPurchase type : object properties : flight_id : type : string date : type : string format : date required : - flight_id - date Flights : title : Flights type : object properties : flights : type : array items : $ref : '#/components/schemas/Flight' FlightsToPurchase : title : FlightsToPurchase type : object properties : flight_requests : type : array items : $ref : '#/components/schemas/FlightToPurchase' securitySchemes : {} Torna a Servizi web .","title":"Interfaccia OpenAPI"},{"location":"serviziweb/geodistances/","text":"Torna a Servizi web . Panoramica Dentro la rete Docker acmesky-network , tutti gli URI sono relativi a http://geographical_distances:8080 . Da fuori Docker, la porta per raggiungere il servizio \u00e8 5000 . Risorsa Descrizione Risorsa per POST /distance Calcola la distanza fra i dati indirizzi. Gli indirizzi vengono prima trasformati in coordinate GPS tramite geocoding (\u00e8 richiesto che gli indirizzi siano il pi\u00f9 possibile precisi, altrimenti il sistema trova le coordinate relative a un luogo il cui indirizzo meglio assomiglia a quello passato come argomento), successivamente la distanza viene calcolata mediante la formula di Haversine [EN] e ritornata in kilometri. ACMESky Richieste POST /distance Calcola la distanza fra i dati indirizzi. Gli indirizzi vengono prima trasformati in coordinate GPS tramite geocoding (\u00e8 richiesto che gli indirizzi siano il pi\u00f9 possibile precisi, altrimenti il sistema trova le coordinate relative a un luogo il cui indirizzo meglio assomiglia a quello passato come argomento), successivamente la distanza viene calcolata mediante la formula di Haversine [EN] e ritornata in kilometri. Parametri Nome Tipo Locations Locations Tipo di ritorno 200 : Double 400 : - Header della richiesta Content-Type : application/json Accept : application/json Modelli Locations Nome Tipo address_1 String address_2 String Interfaccia OpenAPI Nel seguente blocco (cliccare sulla barra con su scritto \"OpenAPI\" in basso per aprirlo) \u00e8 possibile visualizzare l'interfaccia OpenAPI che descrive il funzionamento delle API fornite da Geographical Distances. OpenAPI openapi : 3.0.0 info : title : Geographical Distances version : '1.0' description : Interface that models the operations available for the service that computes geographical distances in ACMESky. servers : - url : 'http://geographical_distances:8080' description : Inside the Docker network - url : 'http://chosen_url:5000' description : Outside the Docker network (chosen_url is a placeholder) paths : /distance : post : summary : calculateDistance operationId : calculateDistance responses : '200' : description : OK content : application/json : schema : type : number format : double minimum : 0 description : Distance between the two addresses. '400' : description : Bad Request requestBody : content : application/json : schema : $ref : '#/components/schemas/Locations' description : '' description : |- Calculates the distance between the given locations. Given addresses are first transformed into coordinates via geocoding, then the distance is computed and returned in kilometers. API for: ACMESky components : schemas : Locations : title : Locations type : object description : 'Represents the two addresses to compute their distance. They are not coordinates, they are addresses.' properties : address_1 : type : string minLength : 1 address_2 : type : string minLength : 1 required : - address_1 - address_2 Torna a Servizi web .","title":"Geographical Distances"},{"location":"serviziweb/geodistances/#panoramica","text":"Dentro la rete Docker acmesky-network , tutti gli URI sono relativi a http://geographical_distances:8080 . Da fuori Docker, la porta per raggiungere il servizio \u00e8 5000 . Risorsa Descrizione Risorsa per POST /distance Calcola la distanza fra i dati indirizzi. Gli indirizzi vengono prima trasformati in coordinate GPS tramite geocoding (\u00e8 richiesto che gli indirizzi siano il pi\u00f9 possibile precisi, altrimenti il sistema trova le coordinate relative a un luogo il cui indirizzo meglio assomiglia a quello passato come argomento), successivamente la distanza viene calcolata mediante la formula di Haversine [EN] e ritornata in kilometri. ACMESky","title":"Panoramica"},{"location":"serviziweb/geodistances/#richieste","text":"","title":"Richieste"},{"location":"serviziweb/geodistances/#post-distance","text":"Calcola la distanza fra i dati indirizzi. Gli indirizzi vengono prima trasformati in coordinate GPS tramite geocoding (\u00e8 richiesto che gli indirizzi siano il pi\u00f9 possibile precisi, altrimenti il sistema trova le coordinate relative a un luogo il cui indirizzo meglio assomiglia a quello passato come argomento), successivamente la distanza viene calcolata mediante la formula di Haversine [EN] e ritornata in kilometri.","title":"POST /distance"},{"location":"serviziweb/geodistances/#parametri","text":"Nome Tipo Locations Locations","title":"Parametri"},{"location":"serviziweb/geodistances/#tipo-di-ritorno","text":"200 : Double 400 : -","title":"Tipo di ritorno"},{"location":"serviziweb/geodistances/#header-della-richiesta","text":"Content-Type : application/json Accept : application/json","title":"Header della richiesta"},{"location":"serviziweb/geodistances/#modelli","text":"","title":"Modelli"},{"location":"serviziweb/geodistances/#locations","text":"Nome Tipo address_1 String address_2 String","title":"Locations"},{"location":"serviziweb/geodistances/#interfaccia-openapi","text":"Nel seguente blocco (cliccare sulla barra con su scritto \"OpenAPI\" in basso per aprirlo) \u00e8 possibile visualizzare l'interfaccia OpenAPI che descrive il funzionamento delle API fornite da Geographical Distances. OpenAPI openapi : 3.0.0 info : title : Geographical Distances version : '1.0' description : Interface that models the operations available for the service that computes geographical distances in ACMESky. servers : - url : 'http://geographical_distances:8080' description : Inside the Docker network - url : 'http://chosen_url:5000' description : Outside the Docker network (chosen_url is a placeholder) paths : /distance : post : summary : calculateDistance operationId : calculateDistance responses : '200' : description : OK content : application/json : schema : type : number format : double minimum : 0 description : Distance between the two addresses. '400' : description : Bad Request requestBody : content : application/json : schema : $ref : '#/components/schemas/Locations' description : '' description : |- Calculates the distance between the given locations. Given addresses are first transformed into coordinates via geocoding, then the distance is computed and returned in kilometers. API for: ACMESky components : schemas : Locations : title : Locations type : object description : 'Represents the two addresses to compute their distance. They are not coordinates, they are addresses.' properties : address_1 : type : string minLength : 1 address_2 : type : string minLength : 1 required : - address_1 - address_2 Torna a Servizi web .","title":"Interfaccia OpenAPI"},{"location":"serviziweb/paymentprovider/","text":"Torna a Servizi web . Panoramica Dentro la rete Docker acmesky-network , tutti gli URI sono relativi a http://payment_provider_backend:8080 . Da fuori Docker, la porta per raggiungere il servizio \u00e8 4001 . Risorsa Descrizione Risorsa per POST /payments/request Crea una richiesta di pagamento per un utente. ACMESky GET /payments/{transaction_id} Ritorna le informazioni relative alla richiesta di pagamento da parte di utente. Utente finale POST /payments/pay Permette l'invio delle informazioni di pagamento per pagare un offerta. Utente finale Richieste POST /payments/request Crea una richiesta di pagamento per un utente. Parametri Nome Tipo PaymentRequest PaymentRequest Tipo di ritorno 200 : PaymentCreationResponse 400 : - Header della richiesta Content-Type : application/json Accept : application/json GET /payments/{transaction_id} Ritorna le informazioni relative alla richiesta di pagamento da parte di utente. Parametri Nome Tipo transaction_id UUID Tipo di ritorno 200 : PaymentRequest 404 : - Header della richiesta Content-Type : application/json Accept : application/json POST /payments/pay Permette l'invio delle informazioni di pagamento per pagare un offerta. Parametri Nome Tipo PaymentData PaymentData Tipo di ritorno 200 : - 400 : Error Header della richiesta Content-Type : application/json Accept : application/json Modelli Error Nome Tipo description String PaymentCreationResponse Nome Tipo redirect_page String transaction_id UUID PaymentData Nome Tipo transaction_id UUID credit_cart_number String cvv String expiration_date Date owner_name String PaymentRequest Nome Tipo amount Double description String payment_receiver String Interfaccia OpenAPI Nel seguente blocco (cliccare sulla barra con su scritto \"OpenAPI\" in basso per aprirlo) \u00e8 possibile visualizzare l'interfaccia OpenAPI che descrive il funzionamento delle API fornite da Payment Provider. OpenAPI openapi : 3.0.0 info : title : Payment Provider version : '1.0' description : Interface that models the operations available for the Payment Provider that supports payments by customers in ACMESky. servers : - url : 'http://payment_provider_backend:8080' description : Inside the Docker network - url : 'http://chosen_url:4001' description : Outside the Docker network (chosen_url is a placeholder) paths : /payments/request : parameters : [] post : summary : createPaymentRequest operationId : createPaymentRequest responses : '200' : description : OK content : application/json : schema : $ref : '#/components/schemas/PaymentCreationResponse' '400' : description : Bad Request description : |- Creates a payment request for a user. API for: ACMESky requestBody : content : application/json : schema : $ref : '#/components/schemas/PaymentRequest' description : '' /payments/pay : parameters : [] post : summary : sendPayment operationId : sendPayment responses : '200' : description : OK '400' : description : Bad Request content : application/json : schema : $ref : '#/components/schemas/Error' description : |- Sends the payment data for paying a request. API for: User requestBody : content : application/json : schema : $ref : '#/components/schemas/PaymentData' description : '' '/payments/{transaction_id}' : get : summary : getPaymentDetails tags : [] responses : '200' : description : OK content : application/json : schema : $ref : '#/components/schemas/PaymentRequest' '404' : description : Not Found operationId : getPaymentDetails parameters : - schema : type : string format : uuid in : path required : true description : ID of transaction name : transaction_id description : |- Gets the information for the payment request for a user. API for: User parameters : - schema : type : string format : uuid name : transaction_id in : path required : true description : ID of the transaction components : schemas : PaymentRequest : title : PaymentRequest type : object properties : amount : type : number format : double minimum : 0 description : type : string payment_receiver : type : string required : - amount - description - payment_receiver PaymentData : title : PaymentData type : object properties : transaction_id : type : string format : uuid credit_cart_number : type : string pattern : '[0-9]{16,16}' cvv : type : string pattern : '[0-9]{3,3}' expiration_date : type : string format : date owner_name : type : string required : - transaction_id - credit_cart_number - cvv - expiration_date - owner_name Error : title : Error type : object properties : description : type : string minLength : 1 required : - description PaymentCreationResponse : title : PaymentCreationResponse type : object properties : redirect_page : type : string minLength : 1 transaction_id : type : string format : uuid required : - redirect_page - transaction_id Torna a Servizi web .","title":"Payment Provider"},{"location":"serviziweb/paymentprovider/#panoramica","text":"Dentro la rete Docker acmesky-network , tutti gli URI sono relativi a http://payment_provider_backend:8080 . Da fuori Docker, la porta per raggiungere il servizio \u00e8 4001 . Risorsa Descrizione Risorsa per POST /payments/request Crea una richiesta di pagamento per un utente. ACMESky GET /payments/{transaction_id} Ritorna le informazioni relative alla richiesta di pagamento da parte di utente. Utente finale POST /payments/pay Permette l'invio delle informazioni di pagamento per pagare un offerta. Utente finale","title":"Panoramica"},{"location":"serviziweb/paymentprovider/#richieste","text":"","title":"Richieste"},{"location":"serviziweb/paymentprovider/#post-paymentsrequest","text":"Crea una richiesta di pagamento per un utente.","title":"POST /payments/request"},{"location":"serviziweb/paymentprovider/#parametri","text":"Nome Tipo PaymentRequest PaymentRequest","title":"Parametri"},{"location":"serviziweb/paymentprovider/#tipo-di-ritorno","text":"200 : PaymentCreationResponse 400 : -","title":"Tipo di ritorno"},{"location":"serviziweb/paymentprovider/#header-della-richiesta","text":"Content-Type : application/json Accept : application/json","title":"Header della richiesta"},{"location":"serviziweb/paymentprovider/#get-paymentstransaction_id","text":"Ritorna le informazioni relative alla richiesta di pagamento da parte di utente.","title":"GET /payments/{transaction_id}"},{"location":"serviziweb/paymentprovider/#parametri_1","text":"Nome Tipo transaction_id UUID","title":"Parametri"},{"location":"serviziweb/paymentprovider/#tipo-di-ritorno_1","text":"200 : PaymentRequest 404 : -","title":"Tipo di ritorno"},{"location":"serviziweb/paymentprovider/#header-della-richiesta_1","text":"Content-Type : application/json Accept : application/json","title":"Header della richiesta"},{"location":"serviziweb/paymentprovider/#post-paymentspay","text":"Permette l'invio delle informazioni di pagamento per pagare un offerta.","title":"POST /payments/pay"},{"location":"serviziweb/paymentprovider/#parametri_2","text":"Nome Tipo PaymentData PaymentData","title":"Parametri"},{"location":"serviziweb/paymentprovider/#tipo-di-ritorno_2","text":"200 : - 400 : Error","title":"Tipo di ritorno"},{"location":"serviziweb/paymentprovider/#header-della-richiesta_2","text":"Content-Type : application/json Accept : application/json","title":"Header della richiesta"},{"location":"serviziweb/paymentprovider/#modelli","text":"","title":"Modelli"},{"location":"serviziweb/paymentprovider/#error","text":"Nome Tipo description String","title":"Error"},{"location":"serviziweb/paymentprovider/#paymentcreationresponse","text":"Nome Tipo redirect_page String transaction_id UUID","title":"PaymentCreationResponse"},{"location":"serviziweb/paymentprovider/#paymentdata","text":"Nome Tipo transaction_id UUID credit_cart_number String cvv String expiration_date Date owner_name String","title":"PaymentData"},{"location":"serviziweb/paymentprovider/#paymentrequest","text":"Nome Tipo amount Double description String payment_receiver String","title":"PaymentRequest"},{"location":"serviziweb/paymentprovider/#interfaccia-openapi","text":"Nel seguente blocco (cliccare sulla barra con su scritto \"OpenAPI\" in basso per aprirlo) \u00e8 possibile visualizzare l'interfaccia OpenAPI che descrive il funzionamento delle API fornite da Payment Provider. OpenAPI openapi : 3.0.0 info : title : Payment Provider version : '1.0' description : Interface that models the operations available for the Payment Provider that supports payments by customers in ACMESky. servers : - url : 'http://payment_provider_backend:8080' description : Inside the Docker network - url : 'http://chosen_url:4001' description : Outside the Docker network (chosen_url is a placeholder) paths : /payments/request : parameters : [] post : summary : createPaymentRequest operationId : createPaymentRequest responses : '200' : description : OK content : application/json : schema : $ref : '#/components/schemas/PaymentCreationResponse' '400' : description : Bad Request description : |- Creates a payment request for a user. API for: ACMESky requestBody : content : application/json : schema : $ref : '#/components/schemas/PaymentRequest' description : '' /payments/pay : parameters : [] post : summary : sendPayment operationId : sendPayment responses : '200' : description : OK '400' : description : Bad Request content : application/json : schema : $ref : '#/components/schemas/Error' description : |- Sends the payment data for paying a request. API for: User requestBody : content : application/json : schema : $ref : '#/components/schemas/PaymentData' description : '' '/payments/{transaction_id}' : get : summary : getPaymentDetails tags : [] responses : '200' : description : OK content : application/json : schema : $ref : '#/components/schemas/PaymentRequest' '404' : description : Not Found operationId : getPaymentDetails parameters : - schema : type : string format : uuid in : path required : true description : ID of transaction name : transaction_id description : |- Gets the information for the payment request for a user. API for: User parameters : - schema : type : string format : uuid name : transaction_id in : path required : true description : ID of the transaction components : schemas : PaymentRequest : title : PaymentRequest type : object properties : amount : type : number format : double minimum : 0 description : type : string payment_receiver : type : string required : - amount - description - payment_receiver PaymentData : title : PaymentData type : object properties : transaction_id : type : string format : uuid credit_cart_number : type : string pattern : '[0-9]{16,16}' cvv : type : string pattern : '[0-9]{3,3}' expiration_date : type : string format : date owner_name : type : string required : - transaction_id - credit_cart_number - cvv - expiration_date - owner_name Error : title : Error type : object properties : description : type : string minLength : 1 required : - description PaymentCreationResponse : title : PaymentCreationResponse type : object properties : redirect_page : type : string minLength : 1 transaction_id : type : string format : uuid required : - redirect_page - transaction_id Torna a Servizi web .","title":"Interfaccia OpenAPI"},{"location":"serviziweb/prontogram/","text":"Torna a Servizi web . Panoramica Dentro la rete Docker acmesky-network , tutti gli URI sono relativi a http://prontogram_backend:8080 . Da fuori Docker, la porta per raggiungere il servizio \u00e8 5001 . Risorsa Descrizione Risorsa per POST /messages Permette di inviare il messaggio a ProntoGram per essere inoltrato all'utente specificato. ACMESky Richieste POST /messages Permette di inviare il messaggio a ProntoGram per essere inoltrato all'utente specificato. Parametri Nome Tipo Message Message Tipo di ritorno 200 : - Header della richiesta Content-Type : application/json Accept : application/json Modelli Message Nome Tipo sender String receiver String body String send_time DateTime Interfaccia OpenAPI Nel seguente blocco (cliccare sulla barra con su scritto \"OpenAPI\" in basso per aprirlo) \u00e8 possibile visualizzare l'interfaccia OpenAPI che descrive il funzionamento delle API fornite da ProntoGram. OpenAPI openapi : 3.0.0 info : title : ProntoGram version : '1.0' description : Interface that models the operations available for ProntoGram in ACMESky. servers : - url : 'http://prontogram_backend:8080' description : Inside the Docker network - url : 'http://chosen_url:5001' description : Outside the Docker network (chosen_url is a placeholder) paths : /messages : post : summary : sendMessage operationId : sendMessage responses : '200' : description : OK description : |- Sends the message to ProntoGram for being dispatched to the actual user. API for: ACMESky requestBody : content : application/json : schema : $ref : '#/components/schemas/Message' components : schemas : Message : title : Message type : object properties : sender : type : string minLength : 1 receiver : type : string minLength : 1 body : type : string minLength : 1 send_time : type : string format : date-time required : - sender - receiver - body Torna a Servizi web .","title":"ProntoGram"},{"location":"serviziweb/prontogram/#panoramica","text":"Dentro la rete Docker acmesky-network , tutti gli URI sono relativi a http://prontogram_backend:8080 . Da fuori Docker, la porta per raggiungere il servizio \u00e8 5001 . Risorsa Descrizione Risorsa per POST /messages Permette di inviare il messaggio a ProntoGram per essere inoltrato all'utente specificato. ACMESky","title":"Panoramica"},{"location":"serviziweb/prontogram/#richieste","text":"","title":"Richieste"},{"location":"serviziweb/prontogram/#post-messages","text":"Permette di inviare il messaggio a ProntoGram per essere inoltrato all'utente specificato.","title":"POST /messages"},{"location":"serviziweb/prontogram/#parametri","text":"Nome Tipo Message Message","title":"Parametri"},{"location":"serviziweb/prontogram/#tipo-di-ritorno","text":"200 : -","title":"Tipo di ritorno"},{"location":"serviziweb/prontogram/#header-della-richiesta","text":"Content-Type : application/json Accept : application/json","title":"Header della richiesta"},{"location":"serviziweb/prontogram/#modelli","text":"","title":"Modelli"},{"location":"serviziweb/prontogram/#message","text":"Nome Tipo sender String receiver String body String send_time DateTime","title":"Message"},{"location":"serviziweb/prontogram/#interfaccia-openapi","text":"Nel seguente blocco (cliccare sulla barra con su scritto \"OpenAPI\" in basso per aprirlo) \u00e8 possibile visualizzare l'interfaccia OpenAPI che descrive il funzionamento delle API fornite da ProntoGram. OpenAPI openapi : 3.0.0 info : title : ProntoGram version : '1.0' description : Interface that models the operations available for ProntoGram in ACMESky. servers : - url : 'http://prontogram_backend:8080' description : Inside the Docker network - url : 'http://chosen_url:5001' description : Outside the Docker network (chosen_url is a placeholder) paths : /messages : post : summary : sendMessage operationId : sendMessage responses : '200' : description : OK description : |- Sends the message to ProntoGram for being dispatched to the actual user. API for: ACMESky requestBody : content : application/json : schema : $ref : '#/components/schemas/Message' components : schemas : Message : title : Message type : object properties : sender : type : string minLength : 1 receiver : type : string minLength : 1 body : type : string minLength : 1 send_time : type : string format : date-time required : - sender - receiver - body Torna a Servizi web .","title":"Interfaccia OpenAPI"},{"location":"serviziweb/travelcompany/","text":"Torna a Servizi web . Panoramica Dentro la rete Docker acmesky-network , tutti gli URI sono relativi a: http://travel_company_1:8080 for Travel Company 1; http://travel_company_2:8080 for Travel Company 2; http://travel_company_3:8080 for Travel Company 3. Da fuori Docker, le porte per raggiungere i servizi sono rispettivamente 6001 , 6002 , 6003 . Risorsa Descrizione Risorsa per buyTransfers Permette di acquistare il trasferimento verso l'aeroporto passando come argomento i dettagli di acquisto. ACMESky buyTransfers Permette di acquistare il trasferimento verso l'aeroporto passando come argomento i dettagli di acquisto. Parametri Nome Tipo PurchaseDetails PurchaseDetails Tipi di ritorno 200 : Response 500 : Error Header della richiesta Content-Type : application/xml Accept : application/xml Modelli Error Nome Tipo description String PurchaseDetails Nome Tipo customer_address String airport_code String departure_transfer_datetime DateTime arrival_transfer_datetime DateTime customer_name String Response Nome Tipo response String Interfaccia OpenAPI Nel seguente blocco (cliccare sulla barra con su scritto \"OpenAPI\" in basso per aprirlo) \u00e8 possibile visualizzare l'interfaccia OpenAPI che descrive il funzionamento delle API fornite da Travel Company. OpenAPI openapi : 3.0.0 info : title : Travel Company version : '1.0' description : Interface that models the operations available for a travel company that offers car transfers from the customers' house and the airports in ACMESky. servers : - url : 'http://travel_company_1:8080' description : Inside the Docker network (for Travel Company 1) - url : 'http://travel_company_2:8080' description : Inside the Docker network (for Travel Company 2) - url : 'http://travel_company_3:8080' description : Inside the Docker network (for Travel Company 3) - url : 'http://chosen_url:6001' description : Outside the Docker network (for Travel Company 1, chosen_url is a placeholder) - url : 'http://chosen_url:6002' description : Outside the Docker network (for Travel Company 2, chosen_url is a placeholder) - url : 'http://chosen_url:6003' description : Outside the Docker network (for Travel Company 3, chosen_url is a placeholder) paths : /transfers/buy : post : summary : buyTransfer operationId : buyTransfers responses : '200' : description : OK content : application/json : schema : $ref : '#/components/schemas/Response' '500' : description : Internal Server Error content : application/json : schema : $ref : '#/components/schemas/Error' requestBody : content : application/xml : schema : $ref : '#/components/schemas/PurchaseDetails' examples : SOAP : value : '<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:trav=\"travelcompany.com.xsd\"><soapenv:Header/><soapenv:Body><trav:buyTransfers><departure_transfer_datetime>2020-01-31T12:38:56</departure_transfer_datetime><customer_address>Corso del Popolo, 25, Roma, Italia</customer_address><airport_code>FCO</airport_code><customer_name>Mario Rossi</customer_name><arrival_transfer_datetime>2020-02-03T12:54:04</arrival_transfer_datetime></trav:buyTransfers></soapenv:Body></soapenv:Envelope>' description : |- Buys the car transfers with the given purchase details. API for: ACMESky parameters : [] components : schemas : PurchaseDetails : title : PurchaseDetails type : object properties : customer_address : type : string airport_code : type : string pattern : '[A-Z]{3,3}' departure_transfer_datetime : type : string format : date-time arrival_transfer_datetime : type : string format : date-time customer_name : type : string required : - customer_address - airport_code - departure_transfer_datetime - arrival_transfer_datetime - customer_name x-examples : {} Error : title : Error type : object properties : description : type : string minLength : 1 required : - description Response : title : Response type : object properties : response : type : string minLength : 1 required : - response Torna a Servizi web .","title":"Travel Company"},{"location":"serviziweb/travelcompany/#panoramica","text":"Dentro la rete Docker acmesky-network , tutti gli URI sono relativi a: http://travel_company_1:8080 for Travel Company 1; http://travel_company_2:8080 for Travel Company 2; http://travel_company_3:8080 for Travel Company 3. Da fuori Docker, le porte per raggiungere i servizi sono rispettivamente 6001 , 6002 , 6003 . Risorsa Descrizione Risorsa per buyTransfers Permette di acquistare il trasferimento verso l'aeroporto passando come argomento i dettagli di acquisto. ACMESky","title":"Panoramica"},{"location":"serviziweb/travelcompany/#buytransfers","text":"Permette di acquistare il trasferimento verso l'aeroporto passando come argomento i dettagli di acquisto.","title":"buyTransfers"},{"location":"serviziweb/travelcompany/#parametri","text":"Nome Tipo PurchaseDetails PurchaseDetails","title":"Parametri"},{"location":"serviziweb/travelcompany/#tipi-di-ritorno","text":"200 : Response 500 : Error","title":"Tipi di ritorno"},{"location":"serviziweb/travelcompany/#header-della-richiesta","text":"Content-Type : application/xml Accept : application/xml","title":"Header della richiesta"},{"location":"serviziweb/travelcompany/#modelli","text":"","title":"Modelli"},{"location":"serviziweb/travelcompany/#error","text":"Nome Tipo description String","title":"Error"},{"location":"serviziweb/travelcompany/#purchasedetails","text":"Nome Tipo customer_address String airport_code String departure_transfer_datetime DateTime arrival_transfer_datetime DateTime customer_name String","title":"PurchaseDetails"},{"location":"serviziweb/travelcompany/#response","text":"Nome Tipo response String","title":"Response"},{"location":"serviziweb/travelcompany/#interfaccia-openapi","text":"Nel seguente blocco (cliccare sulla barra con su scritto \"OpenAPI\" in basso per aprirlo) \u00e8 possibile visualizzare l'interfaccia OpenAPI che descrive il funzionamento delle API fornite da Travel Company. OpenAPI openapi : 3.0.0 info : title : Travel Company version : '1.0' description : Interface that models the operations available for a travel company that offers car transfers from the customers' house and the airports in ACMESky. servers : - url : 'http://travel_company_1:8080' description : Inside the Docker network (for Travel Company 1) - url : 'http://travel_company_2:8080' description : Inside the Docker network (for Travel Company 2) - url : 'http://travel_company_3:8080' description : Inside the Docker network (for Travel Company 3) - url : 'http://chosen_url:6001' description : Outside the Docker network (for Travel Company 1, chosen_url is a placeholder) - url : 'http://chosen_url:6002' description : Outside the Docker network (for Travel Company 2, chosen_url is a placeholder) - url : 'http://chosen_url:6003' description : Outside the Docker network (for Travel Company 3, chosen_url is a placeholder) paths : /transfers/buy : post : summary : buyTransfer operationId : buyTransfers responses : '200' : description : OK content : application/json : schema : $ref : '#/components/schemas/Response' '500' : description : Internal Server Error content : application/json : schema : $ref : '#/components/schemas/Error' requestBody : content : application/xml : schema : $ref : '#/components/schemas/PurchaseDetails' examples : SOAP : value : '<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:trav=\"travelcompany.com.xsd\"><soapenv:Header/><soapenv:Body><trav:buyTransfers><departure_transfer_datetime>2020-01-31T12:38:56</departure_transfer_datetime><customer_address>Corso del Popolo, 25, Roma, Italia</customer_address><airport_code>FCO</airport_code><customer_name>Mario Rossi</customer_name><arrival_transfer_datetime>2020-02-03T12:54:04</arrival_transfer_datetime></trav:buyTransfers></soapenv:Body></soapenv:Envelope>' description : |- Buys the car transfers with the given purchase details. API for: ACMESky parameters : [] components : schemas : PurchaseDetails : title : PurchaseDetails type : object properties : customer_address : type : string airport_code : type : string pattern : '[A-Z]{3,3}' departure_transfer_datetime : type : string format : date-time arrival_transfer_datetime : type : string format : date-time customer_name : type : string required : - customer_address - airport_code - departure_transfer_datetime - arrival_transfer_datetime - customer_name x-examples : {} Error : title : Error type : object properties : description : type : string minLength : 1 required : - description Response : title : Response type : object properties : response : type : string minLength : 1 required : - response Torna a Servizi web .","title":"Interfaccia OpenAPI"}]}